<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="vz1PrlmOl-C4FBrH_at-JOEneuzGOz7AfXa3QVThvy8"><meta name="baidu-site-verification" content="code-4IMpMXQpb6"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon.ico?v=5.1.4"><meta name="keywords" content="gdccwxx"><meta name="description" content="个人博客分享，热爱生活，热爱探索"><meta property="og:type" content="website"><meta property="og:title" content="gdccwxx"><meta property="og:url" content="https://blog.gdccwxx.com/page/4/index.html"><meta property="og:site_name" content="gdccwxx"><meta property="og:description" content="个人博客分享，热爱生活，热爱探索"><meta property="og:locale" content="zh-Hans"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="gdccwxx"><meta name="twitter:description" content="个人博客分享，热爱生活，热爱探索"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_header:"slideDownIn",post_body:"slideDownIn"}},duoshuo:{userId:"undefined",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://blog.gdccwxx.com/page/4/"><title>gdccwxx - :)</title><script>!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-118405225-1","auto"),ga("send","pageview")</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">gdccwxx</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">:)</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/计算机系统基础/basic-computer-sience-chapter5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/计算机系统基础/basic-computer-sience-chapter5/" itemprop="url">计算机系统基础－－第五章(程序的执行)</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-25T08:37:05+08:00">2017-05-25</time></span></div></header><div class="post-body" itemprop="articleBody"><p>按照ISA的复杂程度而言，有复杂指令集（CISC）和精简指令集（RISC）两种类型的计算机。而intel就是属于前者</p><h4 id="程序执行的概述"><a href="#程序执行的概述" class="headerlink" title="程序执行的概述"></a>程序执行的概述</h4><p>指令周期：CPU取出并执行一条指令的时间成为指令周期，不同指令的周期时间可能不同。<br>执行程序顺序:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、取指令：从pc所支出的存储单元取出指令送到指令寄存器</span><br><span class="line">2、指令译码：例如，mov $0x0,%eax，将立即数送到寄存器ebp中</span><br><span class="line">3、计算源操作数地址并取操作数：根据寻址方式确定源操作数地址计算方式，若是存储器数据，则最多一次</span><br><span class="line">4、执行数据操作：在ALU或加法器等运算部件中取出的操作数进行计算</span><br><span class="line">5、计算目的操作数地址并存结果：根据寻址方式确定目的操作数地址计算方式，若是存储器数据，则最多一次，若是寄存器数据，则在进行数据操作时直接存结果到寄存器</span><br><span class="line">6、计算下一条指令地址：顺序执行时，将pc加上当前指令长度即可。如果是转移类指令时，需要根据条件标识、操作码和寻址方式确定下一条指令</span><br></pre></td></tr></table></figure><p></p><h4 id="基本操作："><a href="#基本操作：" class="headerlink" title="基本操作："></a>基本操作：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、读取某储存单元内容(可能是指令或操作数或操作数地址)，并将其装入某个寄存器。</span><br><span class="line">2、把一个数据从某个寄存器存储到给定存储单元。</span><br><span class="line">3、把一个数据从某个寄存器传送到另一个寄存器或ALU。</span><br><span class="line">4、在ALU中进行某种算术运算或逻辑运算，并将结果送到某个寄存器中。</span><br></pre></td></tr></table></figure><h4 id="cup的基本功能和组成"><a href="#cup的基本功能和组成" class="headerlink" title="cup的基本功能和组成"></a>cup的基本功能和组成</h4><p>由程序计数器(PC),指令寄存器(IR)，指令译码器(ID),脉冲源及起停控制逻辑，时序信号产生部件，操作控制信号形成部件，总线控制逻辑，终端机构组成</p><h4 id="打断程序正常执行的事件"><a href="#打断程序正常执行的事件" class="headerlink" title="打断程序正常执行的事件"></a>打断程序正常执行的事件</h4><p>1、内部异常：源自于正在运行程序本身，来自于cpu内部。是必然，同步事件。<br>2、外部中断：源自于正在运行程序的条件，来足浴cpu外部，是偶然，异步事件。</p><h4 id="数据通路基本逻辑和工作原理"><a href="#数据通路基本逻辑和工作原理" class="headerlink" title="数据通路基本逻辑和工作原理"></a>数据通路基本逻辑和工作原理</h4><p>操作元件：多路选择器(MUX)，加法器(ADDER)，算术逻辑部件(ALU)，译码器(Decoder)<br>状态元件：D触发器，这需要建立时间以及保持时间，也称触发器的锁存延迟。<br>数据通路的时钟周期：cycle Time = clk-to-Q(稳定时间)+Longest Delay(处理时间)+ 建立时间+时钟偏移。<br>工作原理：<br><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter5/simpleBus.jpg" alt="simpleBus"><br>数据通路中的部件之间可以通过总线方式连接，ALU及所有的寄存器通过一条内部的公共总线连接起来，已构成单总线结构数据通路，因为在cpu内部成为cpu内总线。<br><strong>1、完成算术或逻辑运算</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其完成R[R3]&lt;-R[R1]+R[R2]操作如下：</span><br><span class="line">1、R1(out),Y(in)</span><br><span class="line">2、R2(out),add,Z(in)</span><br><span class="line">3、Z(out),R3(in)</span><br></pre></td></tr></table></figure><p></p><p><strong>2、从内存读取一个字(指令或数据或数据的地址)</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其完成R[R2]&lt;-M[R[R1]]操作如下：</span><br><span class="line">1、R1(out),MAR(in)</span><br><span class="line">2、read,WMFC(使cpu进行等待)</span><br><span class="line">3、MAR(out),R2(in)</span><br></pre></td></tr></table></figure><p></p><p><strong>3、把一个字(数据)写入内存</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其完成M[R[R2]]&lt;-R[R1]操作如下：</span><br><span class="line">1、R1(out),MDR(in)</span><br><span class="line">2、R2(out),MAR(in)</span><br><span class="line">3、write,WMFC</span><br></pre></td></tr></table></figure><p></p><h4 id="流水线方式下命令的执行"><a href="#流水线方式下命令的执行" class="headerlink" title="流水线方式下命令的执行"></a>流水线方式下命令的执行</h4><p>想象以下，你有一堆衣服，有洗，甩干，晾三个操作，分别时间是40,30,20。有洗衣机和甩干机，晾必须得自己操作，当然，洗衣间衣服的时间是40+30+20,若洗n件衣服，依然还是使用这种算法，则总时间为n(40+30+20),而我们最好的方法是：</p><p><em>在洗第n件衣服时，正好在甩干第n-1件，在晾第n-2件。而大家都同时以40分钟时间为标准，因此。最后的总时间为：40n+30+20，节省不少时间。</em><br>在计算机中也是如此，设计原则是：<br><strong>指令流水段个数以最复杂指令所用的功能段数为准，流水段的长度以最复杂的功能段的操作所用的时间为准。</strong><br>因此，比较适合流水线的指令集特征为：<br>1、指令长度尽量一致。<br>2、指令格式尽量规整，尽量保证源寄存器的位置相同<br>3、采用load/store型指令风格(指令集中只有load指令和store指令能访问内存储器，其他一律不行)<br>4、数据和指令要在寄存器中“对齐存放”</p><h4 id="流水线方式下出现问题"><a href="#流水线方式下出现问题" class="headerlink" title="流水线方式下出现问题"></a>流水线方式下出现问题</h4><p>1、结构冒险：可能逻辑A与逻辑D存放的正好是同一个寄存器，而同时需要运行这条指令，造成结构冒险，由于硬件共享产生的问题。<br>解决方案：<br>(1)、规定一个部件的每条指令只能使用一次，而且只能特定阶段使用<br>(2)、通过设置多个独立的部件来避免资源的冲突</p><p>2、数据冒险：后面的指令用到前面指令的运算结果，前面的指令还没有完成，结果还没有算出，造成数据冒险。<br>解决方案：<br>(1)、由编译器在数据相关的指令之间加若干个nop(空操作指令)指令，等待上一条数据的产生<br>(2)、采用数据转发机制，即结果出来后通过旁路放到相关的exce阶段的ALU输入端<br>(3)、通过硬件阻塞(插入气泡)来延迟load命令执行<br>(4)、通过寄存器的读写操作进行特殊处理，保证在一个时钟的前半周期进行寄存器写，在后半期进行寄存器读。</p><p>3、控制冒险:<br>由于中断或转移指令的执行顺序，可能发生控制冒险。<br>可通过插入气泡或插入空操作符解决。</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>计算机程序的运行并没有那么简单，从简单的代码，转化为汇编之后，再变成单条的运行，之间发生了奇妙的变化，这章的学习让我明白软件的运行并不是简单我们看到的代码，而是分解之后单条单条的汇编代码，每条汇编代码又需要执行条小周期，才能完成一条汇编代码。而每条小周期还能变成一个完整的流水线。即使每个流水线都是有各种各样的问题，但解决流水线问题之后，速度是质的提升。这种思想也改变了我的思维，对代码效率的考虑。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/计算机系统基础/basic-computer-sience-chapter4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/计算机系统基础/basic-computer-sience-chapter4/" itemprop="url">计算机系统基础－－第四章(程序的链接)</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-24T08:26:05+08:00">2017-05-24</time></span></div></header><div class="post-body" itemprop="articleBody"><h4 id="什么是程序的链接？"><a href="#什么是程序的链接？" class="headerlink" title="什么是程序的链接？"></a>什么是程序的链接？</h4><p><em>将gcc生成的若干个.0文件为后缀的，vc输出为.obj为后缀的可重定位目标文件组合起来，生成一个可执行目标文件</em></p><h4 id="程序链接的好处："><a href="#程序链接的好处：" class="headerlink" title="程序链接的好处："></a>程序链接的好处：</h4><p>1、模块化(可分成不同模块全部编译成.o文件后链接即可运行。而不仅仅是只有一个.c文件，对于大工程来说清晰划分)<br>2、效率高(由于可以使多个文件同时编写，多个模块同时修改，因此这样提升了效率)</p><h5 id="在链接先进行编译和汇编，在第三章聊过"><a href="#在链接先进行编译和汇编，在第三章聊过" class="headerlink" title="在链接先进行编译和汇编，在第三章聊过"></a>在链接先进行编译和汇编，在第三章聊过</h5><h4 id="可执行文件与-o文件的汇编差别在哪？"><a href="#可执行文件与-o文件的汇编差别在哪？" class="headerlink" title="可执行文件与.o文件的汇编差别在哪？"></a>可执行文件与.o文件的汇编差别在哪？</h4><p>由于可执行文件是将可重定位二进制文件重新组合，因此其自身的虚拟地址转化为了逻辑地址,如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// test.c</span><br><span class="line">int main(int i,int j)&#123;</span><br><span class="line">	int x = i+j;</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line">//使用objdump -d test.o反汇编出来的.o文件</span><br><span class="line">// test.o</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:	55                   	push   %rbp       </span><br><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   4:	89 7d ec             	mov    %edi,-0x14(%rbp)</span><br><span class="line">   7:	89 75 e8             	mov    %esi,-0x18(%rbp)</span><br><span class="line">   a:	8b 55 ec             	mov    -0x14(%rbp),%edx</span><br><span class="line">   d:	8b 45 e8             	mov    -0x18(%rbp),%eax</span><br><span class="line">  10:	01 d0                	add    %edx,%eax</span><br><span class="line">  12:	89 45 fc             	mov    %eax,-0x4(%rbp)</span><br><span class="line">  15:	8b 45 fc             	mov    -0x4(%rbp),%eax</span><br><span class="line">  18:	5d                   	pop    %rbp</span><br><span class="line">  19:	c3                   	retq   </span><br><span class="line">//每个.o文件开头都是以0开始，还没有被链接成位可执行文件，在其内部为虚拟地址</span><br><span class="line">//使用objdump -d test反汇编出来的可执行文件</span><br><span class="line">//test</span><br><span class="line">00000000004004d6 &lt;main&gt;:</span><br><span class="line">  4004d6:	55                   	push   %rbp</span><br><span class="line">  4004d7:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">  4004da:	89 7d ec             	mov    %edi,-0x14(%rbp)</span><br><span class="line">  4004dd:	89 75 e8             	mov    %esi,-0x18(%rbp)</span><br><span class="line">  4004e0:	8b 55 ec             	mov    -0x14(%rbp),%edx</span><br><span class="line">  4004e3:	8b 45 e8             	mov    -0x18(%rbp),%eax</span><br><span class="line">  4004e6:	01 d0                	add    %edx,%eax</span><br><span class="line">  4004e8:	89 45 fc             	mov    %eax,-0x4(%rbp)</span><br><span class="line">  4004eb:	8b 45 fc             	mov    -0x4(%rbp),%eax</span><br><span class="line">  4004ee:	5d                   	pop    %rbp</span><br><span class="line">  4004ef:	c3                   	retq   </span><br><span class="line">// 由于我的机子是8g内存，因此开头以400...开头</span><br><span class="line">// test.o与test相比，test经过链接后，将虚拟地址转化成为逻辑地址</span><br></pre></td></tr></table></figure><p></p><h4 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h4><p>ELF格式<br>每个可执行文件都有一个ELF头，里面包括着可执行文件的信息。</p><h4 id="ELF头"><a href="#ELF头" class="headerlink" title="ELF头"></a>ELF头</h4><p><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter4/elfImage.jpg" alt="elfImage"><br>夹在ELF头和节头部表之间的都是节。一个典型的ELF可重定位目标文件包含下面几个节：<br>.text：已编译程序的机器代码。<br>.rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。<br>.data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。<br>.bss：未初始化的全局C变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。<br>.symtab：一个符号表（symbol table），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。<br>.rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。<br>.rel.data：被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。<br>.debug：一个调试符号表，其有些表目是程序中定义的局部变量和类型定义，有些表目是程序中定义和引用的全局变量，有些是原始的C源文件。只有以-g选项调用编译驱动程序时，才会得到这张表。<br>.line：原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译驱动程序时，才会得到这张表。<br>.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。<br>旁注：为什么未初始化的数据称为.bss?<br>用术语.bss来表示未初始化的数据是很普遍的。它起始于IBM 704汇编语言（大约在1957年）中”块存储开始（Block Storage Start）“指令的首字母缩写，并沿用至今。一个记住区分.data和.bss节的简单方法是把“bss”看成是“更好地节省空间（Better Save Space）！“的缩写。</p><h4 id="符号表和符号解析"><a href="#符号表和符号解析" class="headerlink" title="符号表和符号解析"></a>符号表和符号解析</h4><h5 id="符号表的类型"><a href="#符号表的类型" class="headerlink" title="符号表的类型"></a>符号表的类型</h5><p>1、在模块m中定义冰杯其他模块引用的全局符号<br>2、在其他模块定义并且被m引用的外部符号<br>3、在模块m中定义并在m中引用的本地符号</p><h5 id="使用readelf-s-prog-o查看符号表"><a href="#使用readelf-s-prog-o查看符号表" class="headerlink" title="使用readelf -s prog.o查看符号表"></a>使用readelf -s prog.o查看符号表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">readelf -s main.o</span><br><span class="line">Symbol table &apos;.symtab&apos; contains 11 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     8: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 buf</span><br><span class="line">     9: 0000000000000000    16 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND swap</span><br><span class="line">readelf -s swap.o</span><br><span class="line">Symbol table &apos;.symtab&apos; contains 12 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     5: 0000000000000000     8 OBJECT  LOCAL  DEFAULT    5 bufp1</span><br><span class="line">     9: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 bufp0</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND buf</span><br><span class="line">    11: 0000000000000000    60 FUNC    GLOBAL DEFAULT    1 swap</span><br></pre></td></tr></table></figure><p><em>GLOBAL位全局变量，LOCAL为局部变量，swap为函数，Ndx位本地变量，UND为undefined</em></p><h5 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h5><h5 id="全局符号的强弱特性"><a href="#全局符号的强弱特性" class="headerlink" title="全局符号的强弱特性"></a>全局符号的强弱特性</h5><p>定义：函数名和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。<br>例如上面的，main,buf,swap,bufp0是 强符号,bufp1位本地符号，本地符号无强弱之分。</p><p>多重定义符号处理：<br><strong>规则1：强符号不能多次定义，也即强符号只能被定义一次，否则链接错误<br>规则2：若一个符号被说明为一次强符号定义和多个弱符号定义，则按强符号为准<br>规则3：若有多个弱符号定义，则任选其中一个</strong></p><h5 id="强弱符号链接错误解决方案："><a href="#强弱符号链接错误解决方案：" class="headerlink" title="强弱符号链接错误解决方案："></a>强弱符号链接错误解决方案：</h5><p>1、尽量避免使用全局符号<br>2、把全局符号定义位static，这样就没有强弱之分<br>3、尽量要给全局变量赋初值使其变成强符号<br>4、外部全局变量尽量使用extern</p><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p>规则：<br>函数调用采用相对重定位<br>即使用R_386_PC32:ADDR(r_sym)-((ADDR(.text)+ r_offset) - init)<br>全局变量采用绝对重定位<br>即使用R_386_32把32位的地址值直接代替</p><h6 id="重定位的工作"><a href="#重定位的工作" class="headerlink" title="重定位的工作"></a>重定位的工作</h6><p>1、节和定义符号的重定位<br>2、引用符号的重定位</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>1、静态链接：将用户程序中使用的库文件完整拷贝形成一个完整的可执行文件<br>优点：可随时执行文件，可执行文件不会因为库文件丢失而无法执行<br>缺点：导致相同库文件多个备份<br>2、动态链接：根据代码、数据、重定位和符号表信息，能在执行目标文件是装入或运行被动态的装入内存并自动链接<br>优点：减少库文件的多个备份<br>缺点：缺少库文件无法运行</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>至此，第四章也完成了。这一章主要讲的是生成可执行文件的过程，由最初始的编辑代码，然后将其预编译，编译，汇编，链接，生成可执行文件。这个过程是不仅由我们看到的小黑框那么简单，这段时间还经历着将代码转成汇编，将所定义的全局变量以及函数名称建表，把各个符号通过重定位形成一个最终没有缺失的可执行文件。第四章让我很清晰的清楚可执行文件的生成，也把当初的黑匣子打开，让我更深刻的理解其工作原理。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/计算机系统基础/basic-computer-sience-chapter3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/计算机系统基础/basic-computer-sience-chapter3/" itemprop="url">计算机系统基础－－第三章(程序的转换及机器级表示)</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-23T16:41:08+08:00">2017-05-23</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="生成机器代码的过程"><a href="#生成机器代码的过程" class="headerlink" title="生成机器代码的过程"></a>生成机器代码的过程</h3><p>1、预处理。：例如，在C语言中有程序以#开头的语句，在源程序中插入所有用的#include命令指定的文件和用#define申明的宏<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -E prog1.c -o prog1.i  //对prog1.c进行预处理，预处理结果位prog1.i</span><br></pre></td></tr></table></figure><p></p><p>2、编译。将预处理后的源程序文件编译产生相应的汇编语言程序<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S prog1.i -o prog1.s或gcc -S prog1.c -o prog1.s    //对prog1.i或者prog1.c进行编译，生成汇编代码文件prog1.s</span><br></pre></td></tr></table></figure><p></p><p>3、汇编。由汇编程序将汇编语言程序文件转换位可重定位的机器语言目标代码文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c prog1.s -o prog1.o //对prog1.s进行汇编，生成可重定位目标文件prog1.o</span><br></pre></td></tr></table></figure><p></p><p>3、汇编。由汇编程序将汇编语言程序文件转换位可重定位的机器语言目标代码文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc prog1.o prog2.o -o prog     //将两个可重定位目标文件prog1.o prog2.o链接起来，生成可执行文件prog</span><br></pre></td></tr></table></figure><p></p><h3 id="可以使用gdb来进行调试"><a href="#可以使用gdb来进行调试" class="headerlink" title="可以使用gdb来进行调试"></a>可以使用gdb来进行调试</h3><p>在Linux中自带GNU调试工具gdb调试和跟踪。<br>在生成.o文件后使用objdump -d test.o来进行反汇编查看代码<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// test.c</span><br><span class="line">int add(int i,int j)&#123;</span><br><span class="line">	int x = i+j;</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line">// test.o</span><br><span class="line">0000000000000000 &lt;add&gt;:</span><br><span class="line">   0:	55                   	push   %rbp</span><br><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   4:	89 7d ec             	mov    %edi,-0x14(%rbp)</span><br><span class="line">   7:	89 75 e8             	mov    %esi,-0x18(%rbp)</span><br><span class="line">   a:	8b 55 ec             	mov    -0x14(%rbp),%edx</span><br><span class="line">   d:	8b 45 e8             	mov    -0x18(%rbp),%eax</span><br><span class="line">  10:	01 d0                	add    %edx,%eax</span><br><span class="line">  12:	89 45 fc             	mov    %eax,-0x4(%rbp)</span><br><span class="line">  15:	8b 45 fc             	mov    -0x4(%rbp),%eax</span><br><span class="line">  18:	5d                   	pop    %rbp</span><br><span class="line">  19:	c3                   	retq</span><br></pre></td></tr></table></figure><p></p><p>MASM采用的是Intel格式的汇编代码<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV [BX+DI-6],CL   //其对大小写不明感，且目的操作数在做，而源操作数在右</span><br></pre></td></tr></table></figure><p></p><p>AT&amp;T方式(教材使用方式)<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov %ecx,(%ebx,%edi,-6)  // R[ecx] &lt;- R[ebx]+M[R[edi]-6]</span><br></pre></td></tr></table></figure><p></p><p>寄存器组织和寻址方式</p><p>通用寄存器（General Pupose Regesters，32位，8个）</p><p>段寄存器（Segment Registers，16位，6个）</p><p>程序状态与控制寄存器（Program Status and Control Register，32位，1个）</p><p>指令指针寄存器（Instruction Pointer，32位，1个）</p><h4 id="1-通用寄存器"><a href="#1-通用寄存器" class="headerlink" title="1.通用寄存器"></a>1.通用寄存器</h4><p>EAX：累加器（Accumulator，针对操作数和结果数据的）</p><p>EBX：基址寄存器（Base，DS段中的数据指针）</p><p>ECX：计数器（Count，字符串和循环操作的）</p><p>EDX：数据寄存器（Data，I/O指针）</p><p>以上4个寄存器主要用在算术运算指令中，常常用来保存常量与变量的值。</p><p>EBP：扩展基质指针寄存器（Base Pointer，SS段中栈内数据指针）</p><p>ESI：源变址寄存器（Source Index，字符串操作源指针）</p><p>EDI：目的变址寄存器（Destination Index，字符串操作目标指针）</p><p>ESP：栈指针寄存器（Stack Pointer，SS段中栈指针）</p><p>以上4个寄存器主要用作保存内存地址的指针。</p><h4 id="2-段寄存器"><a href="#2-段寄存器" class="headerlink" title="2.段寄存器"></a>2.段寄存器</h4><p>CS：代码段寄存器（Code Segment）</p><p>SS：栈段寄存器（Stack Segment）</p><p>DS：数据段寄存器（Data Segment）</p><p>ES：附加数据段寄存器（Extra Data Segment）</p><p>FS：数据段寄存器（Data Segment）</p><p>GS：数据段寄存器（Data Segment）</p><p>CS寄存器用于存放应用程序代码所在段的段基址，SS寄存器用于存放栈段的段基址，DS寄存器用于存放数据段的段基址。ES、FS、GS寄存器用来存放程序使用的附加数据段的段基址。</p><p><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter3/purposeRegisters.jpg" alt="purposeRegiesters"><br><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter3/sliceRegister.jpg" alt="sliceRegiester"></p><h4 id="3-程序状态与控制寄存器"><a href="#3-程序状态与控制寄存器" class="headerlink" title="3.程序状态与控制寄存器"></a>3.程序状态与控制寄存器</h4><p>EFLAGS：Flag Register，标志寄存器<br><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter3/flagRegister.gif" alt="标志寄存器"><br><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter3/eflagRegister.png" alt="eflag"></p><h5 id="运算结果标志位"><a href="#运算结果标志位" class="headerlink" title="运算结果标志位"></a>运算结果标志位</h5><p>1、进位标志CF(Carry Flag)<br>进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。<br>使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。<br>2、奇偶标志PF(Parity Flag)<br>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。<br>利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。<br>3、辅助进位标志AF(Auxiliary Carry Flag)<br>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：<br>(1)、在字操作时，发生低字节向高字节进位或借位时；<br>(2)、在字节操作时，发生低4位向高4位进位或借位时。<br>对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。<br>4、零标志ZF(Zero Flag)<br>零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br>5、符号标志SF(Sign Flag)<br>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。<br>6、溢出标志OF(Overflow Flag)<br>溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。<br>“溢出”和“进位”是两个不同含义的概念，不要混淆。</p><h5 id="状态控制标志位"><a href="#状态控制标志位" class="headerlink" title="状态控制标志位"></a>状态控制标志位</h5><p>状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。<br>1、追踪标志TF(Trap Flag)<br>当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。<br>指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其它办法来改变其值。<br>2、中断允许标志IF(Interrupt-enable Flag)<br>中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：<br>(1)、当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；<br>(2)、当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。<br>CPU的指令系统中也有专门的指令来改变标志位IF的值。<br>3、方向标志DF(Direction Flag)<br>方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值。</p><h5 id="32位标志寄存器增加的标志位"><a href="#32位标志寄存器增加的标志位" class="headerlink" title="32位标志寄存器增加的标志位"></a>32位标志寄存器增加的标志位</h5><p>1、I/O特权标志IOPL(I/O Privilege Level)<br>I/O特权标志用两位二进制位来表示，也称为I/O特权级字段。该字段指定了要求执行I/O指令的特权级。如果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常。<br>2、嵌套任务标志NT(Nested Task)<br>嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下：<br>(1)、当NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作；<br>(2)、当NT=1，通过任务转换实现中断返回。<br>3、重启动标志RF(Restart Flag)<br>重启动标志RF用来控制是否接受调试故障。规定：RF=0时，表示“接受”调试故障，否则拒绝之。在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1。<br>4、虚拟8086方式标志VM(Virtual 8086 Mode)<br>如果该标志的值为1，则表示处理机处于虚拟的8086方式下的工作状态，否则，处理机处于一般保护方式下的工作状态</p><h4 id="4-指令指针寄存器"><a href="#4-指令指针寄存器" class="headerlink" title="4.指令指针寄存器"></a>4.指令指针寄存器</h4><p>EIP：指令指针寄存器（Instruction Pointer），存放下次将要执行的指令在代码段的偏移量。</p><h3 id="七种寻址方式"><a href="#七种寻址方式" class="headerlink" title="七种寻址方式"></a>七种寻址方式</h3><p><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter3/findWay.png" alt="findWay"><br>定义以下几个类型<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">float a[100];</span><br><span class="line">short b[4][4];</span><br></pre></td></tr></table></figure><p></p><p>假设x的基址位100，每个int元素占4bit，则<br>a[i] = 104+i4 //比例变址<br>b[i][j] = 504+i8+j*2 //基址+比例变址+位移<br>x = 100 // 基址<br><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter3/stackValue.png" alt></p><h3 id="IA-32常用指令及其操作"><a href="#IA-32常用指令及其操作" class="headerlink" title="IA-32常用指令及其操作"></a>IA-32常用指令及其操作</h3><h3 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h3><p>1、mov movb(比特), movw(字), movl(双字)<br>2、movs 符号扩展传送指令<br>3、movz 零扩展传送指令<br>4、xchg 数据交换指令<br>5、push 压栈<br>6、pop 退栈<br>7、lea 地址传送指令<br>8、in,out 输入输出I/O指令<br>9、pushf,popf 标志传送指令</p><h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>符号位扩展：<br>八位扩展为十六位<br>由 00001000 -&gt; 1111111100001000<br>零扩展：<br>八位扩展为十六位<br>由 00001000 -&gt; 0000000000001000<br>假设val 和ptr声明如下<br><strong><br>val_type val;<br>contofptr_type <em>ptr;<br>已知上述类型val_type和contofptr_type是用typeof声明的数据类型，且val存储在累加器al/ax/eax中，ptr存储在edx中，现有以下两条C语言语句：<br>val= (val_type) </em>ptr;<br>*ptr = (contofptr_type) val;<br>写出以下组合类型的mov指令实现</strong></p><table><thead><tr><th>val_type</th><th>contofptr_type</th></tr></thead><tbody><tr><td>char</td><td>char</td></tr><tr><td>int</td><td>char</td></tr><tr><td>unsigned</td><td>int</td></tr><tr><td>int</td><td>unsigned char</td></tr><tr><td>unsigned</td><td>unsigned char</td></tr><tr><td>unsigned short</td><td>int</td></tr></tbody></table><p>答案：</p><table><thead><tr><th></th><th>val_type</th><th>contofptr_type</th><th>语句一对应的操作</th><th>语句二对应的操作</th></tr></thead><tbody><tr><td></td><td>char</td><td>char</td><td>movb (%edx),%al //传送</td><td>movb %al,(%edx)//传送</td><td></td></tr><tr><td></td><td>int</td><td>char</td><td>movsb (%edx),%eax // 符号位扩展，传送</td><td>movb %al,(%edx) //截断，传送</td><td></td></tr><tr><td></td><td>unsigned</td><td>int</td><td>movl (%edx),%eax //传送</td><td>movl %eax,(%edx) //传送</td><td></td></tr><tr><td></td><td>int</td><td>unsigned char</td><td>movzbl (%edx),%eax // 零扩展，传送</td><td>movb %al,(%edx) //截断，传送</td><td></td></tr><tr><td></td><td>unsigned</td><td>unsigned char</td><td>movzbl (%edx),%eax // 零扩展，传送</td><td>movb %al,(%edx) //截断，传送</td><td></td></tr><tr><td></td><td>unsigned short</td><td>int</td><td>movw (%edx),%ax // 截断，传送</td><td>movzwl %ax,(%edx) //零扩展，传送</td><td></td></tr></tbody></table><p>其在寄存器中以小端方式储存<br><strong>即|12345678H|-&gt; |78H|56H|34H|12H|</strong></p><h5 id="按位运算指令"><a href="#按位运算指令" class="headerlink" title="按位运算指令"></a>按位运算指令</h5><p>1、NOT单操作数每位取反<br>2、AND对双操作数按位逻辑“与”<br>3、OR对双操作数按位逻辑“或”<br>4、XOR对双操作数按位逻辑“异或”<br>5、TEST根据两个操作数相“与”的结果来设置条件标志<br>6、SHL逻辑左移，每左移一次，最高位送入cf，并在低位补0<br>7、SHR逻辑右移，每右移一次，最低位送入cf，并在高位补0<br>8、SAL算术左移，每左移一次，最高位送入cf，并在低位补0，若符号位发生变化，则of=1，表示左移溢出<br>9、SAR算术右移，每右移一次，最低位送入cf，并在高位补0<br>10、ROL循环左移，每左移一次，最高位移到最低位，并送入cf<br>11、ROR循环右移，每右移一次，最低位移到最高位，并送入cf<br>12、RCL带循环左移，将CF作为操作数的一部分循环左移<br>13、RCR带循环右移，将CF作为操作数的一部分循环右移</p><h5 id="控制转移指令JMP"><a href="#控制转移指令JMP" class="headerlink" title="控制转移指令JMP"></a>控制转移指令JMP</h5><h5 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h5><h5 id="根据单个标志位的状态判断转移的指令"><a href="#根据单个标志位的状态判断转移的指令" class="headerlink" title="根据单个标志位的状态判断转移的指令"></a>根据单个标志位的状态判断转移的指令</h5><table><thead><tr><th>指令</th><th>转移条件</th><th>说明</th></tr></thead><tbody><tr><td>JC DEST</td><td>CF=1</td><td>有进位/借位</td></tr><tr><td>JNC DEST</td><td>CF=0</td><td>无进位/借位</td></tr><tr><td>JE/JZ DEST</td><td>ZF=1</td><td>相等/等于零</td></tr><tr><td>JNE/JNZ DEST</td><td>ZF=0</td><td>不相等/不等于零</td></tr><tr><td>JS DEST</td><td>SF=1</td><td>是负数</td></tr><tr><td>JNS DEST</td><td>SF=0</td><td>是正数</td></tr><tr><td>JO DEST</td><td>OF=1</td><td>有溢出</td></tr><tr><td>JNO DEST</td><td>OF=0</td><td>无溢出</td></tr><tr><td>JP/JPE DEST</td><td>PF=1</td><td>有偶数个“1”</td></tr><tr><td>JNP/JPO DEST</td><td>PF=0</td><td>有奇数个“1”</td></tr></tbody></table><h5 id="根据两个无符号数的比较结果判断转移的指令"><a href="#根据两个无符号数的比较结果判断转移的指令" class="headerlink" title="根据两个无符号数的比较结果判断转移的指令"></a>根据两个无符号数的比较结果判断转移的指令</h5><table><thead><tr><th>指令</th><th>转移条件</th><th>含义</th></tr></thead><tbody><tr><td>JG/JNLE DEST</td><td>SF=OF AND ZF=0</td><td>有符号数A&gt;B</td></tr><tr><td>JGE/JNL DEST</td><td>SF=OF OR ZF=1</td><td>有符号数A≥B</td></tr><tr><td>JL/JNGE DEST</td><td>SF≠OF AND ZF=0</td><td>有符号数A&lt;B</td></tr><tr><td>JLE/JNG DEST</td><td>SF≠OF OR ZF=1</td><td>有符号数A≤B</td></tr></tbody></table><h5 id="根据两个有符号数的比较结果判断转移的指令"><a href="#根据两个有符号数的比较结果判断转移的指令" class="headerlink" title="根据两个有符号数的比较结果判断转移的指令"></a>根据两个有符号数的比较结果判断转移的指令</h5><table><thead><tr><th>指令</th><th>转移条件</th><th>含义</th></tr></thead><tbody><tr><td>JG/JNLE DEST</td><td>SF=OF AND ZF=0</td><td>有符号数A&gt;B</td></tr><tr><td>JGE/JNL DEST</td><td>SF=OF OR ZF=1</td><td>有符号数A≥B</td></tr><tr><td>JL/JNGE DEST</td><td>SF≠OF AND ZF=0</td><td>有符号数A&lt;B</td></tr><tr><td>JLE/JNG DEST</td><td>SF≠OF OR ZF=1</td><td>有符号数A≤B</td></tr></tbody></table><h3 id="IA-32的栈、栈帧及其结构"><a href="#IA-32的栈、栈帧及其结构" class="headerlink" title="IA-32的栈、栈帧及其结构"></a>IA-32的栈、栈帧及其结构</h3><p><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter3/stackBP.jpg" alt="static picture"></p><h5 id="注：为保证其在内存中的整齐，一般的存在为16的倍数。"><a href="#注：为保证其在内存中的整齐，一般的存在为16的倍数。" class="headerlink" title="注：为保证其在内存中的整齐，一般的存在为16的倍数。"></a>注：为保证其在内存中的整齐，一般的存在为16的倍数。</h5><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>本章至此也基本结束了，通过这章的学习，让我更清晰程序的内部工作原理，对优化程序也有了一定的见解。比如递归程序消耗内存，以及switch要查表才可以找到相应的选项。对汇编程序也有了一定的理解。虽然并不是那么深刻。但对以后思考代码的逻辑性以及效率性有了一定的帮助。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/计算机系统基础/basic-computer-sience-chapter2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/计算机系统基础/basic-computer-sience-chapter2/" itemprop="url">计算机系统基础－－第二章(数据的机器级表示与处理)</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-22T21:20:53+08:00">2017-05-22</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h3><p>即将不同的数值转换，例如：二、八、十六进制的相互转换<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">八进制转二进制：　0 Q = 000 B    1 Q = 001 B     7 Q = 111 B</span><br><span class="line">十六进制转二进制：　0 H = 0000 B      5 H =0101 B     F H = 1111 B</span><br><span class="line">tips: 可知八进制转二进制与十六进制转二进制分别对应着３位以及４位的二进制</span><br></pre></td></tr></table></figure><p></p><p>其他进制转二进制，例如：十进制与二进制的相互转换<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 D = 0000 H    10 D = 1010 B   100 D = 1100100 B</span><br><span class="line">而无明显进制位数比较</span><br></pre></td></tr></table></figure><p></p><p>多进制转化为10进制，例如16进制转化为10进制<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 H = 1*16^0 D      F H = 15*16^0 D     8FF H = 8*16^2+15*16^1+15*16^0 D</span><br><span class="line">可较为明确的转化</span><br></pre></td></tr></table></figure><p></p><p>结论：多进制转换为二进制无明显比较。可由多进制转化为10进制后，再转化为其他进制。可参<a href="https://github.com/gdccwxx/just-play/tree/master/hexConversion" target="_blank" rel="noopener">简易的进制转换器</a></p><h3 id="定点编码表示"><a href="#定点编码表示" class="headerlink" title="定点编码表示"></a>定点编码表示</h3><h5 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h5><p>也称“符号－数值”<br>规则：<br>１、当Xt 为正数时，　Xn-1 = 0 Xi=X’i(0&lt;=i&lt;=n-2);<br>２、当Xt 为负数时，　Xn-1 = 1 Xi=X’i(0&lt;=i&lt;=n-2);<br>即：-10 用八位原码表示为10001010B，10 用八位原码表示为00001010B<br>优点：真之对应关系直接方便简单，而且用原码实现乘除运算也较为简单。<br>缺点：０表示不唯一(0000,1000都表示0)加减运算需判断是否同好或异号。<br>运用：现代计算机中不用原码表示正数，只用定点源码小数表示浮点数的尾数部分。</p><h5 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h5><p>也称“２－补码”<br>规则：<br>１、当Xt 为正数时，　[Xt]补　= Xt = M+Xt(mod M);<br>２、当Xt 为负数时，　[Xt]补　= M - |Xt| = M+Xt(mod M);<br>即：[1101100]补　= 2^8 + 1101100 = 100000000 + 1101100(mod 2^8) = 01101100<br>[-1101100]补　= 2^8 - 1101100 = 100000000 - 1101100 = 10000000 + (1111111 - 1101100) + 1 = 10000000 + 0010011 + 1(mod 2^8) = 10010100<br>优点：１、减少了-0与+0的切换<br>2、占用少一个编码表示，补码比原码能多表示一个最小负数，可以用-2^(n-1)来表示最小负数。<br>3、两数的补码之和（差）=两数和（差）的补码。<br>运用：在计算机中，补码用来表示带符号正数。</p><h5 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h5><p>规则：<br>正数和原码相同，负数的补码采用“各位取反，末尾加1”<br>即： [01100]反 = [10100]反<br>缺点：1、0的表示不唯一。<br>2、表数范围比补码少一个最小负数。<br>3、运算时必须考虑循环进位。<br>运用：反码在计算机中很少被使用，有事做数码变换的中间表示形式（我们可以快速从反码知道原码和补码）。</p><h5 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h5><p>规则：<br>[E]移 = 偏置常数 + E （偏置常数通常取2^(n-1)或2^(n-1)-1）<br>运用：通常表示浮点数的阶（即指数）</p><h5 id="浮点数的表示-IEEE754浮点数"><a href="#浮点数的表示-IEEE754浮点数" class="headerlink" title="浮点数的表示(IEEE754浮点数)"></a>浮点数的表示(IEEE754浮点数)</h5><p>IEEE754浮点数的表示：<br><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter2/ieee754image.png" alt="ieee754image"><br><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter2/IEEE754_chart.jpg" alt="chart_of_iee754"><br>sign: 符号位，0表示正数1表示负数<br>exponent： 阶码，由偏置常数+偏移量组成<br>function： 位数</p><h5 id="为什么要有IEEE754标准？"><a href="#为什么要有IEEE754标准？" class="headerlink" title="为什么要有IEEE754标准？"></a>为什么要有IEEE754标准？</h5><p><strong>答：在此标准出来之前，不同电脑中的浮点数表示不唯一，一个程序由此电脑移到彼电脑可能需要重新编码。为了让程序员更加专心于程序的本身，而非多个不同电脑的差异做无用功，因此出现IEEE754标准</strong></p><h5 id="什么是IEEE754标准？"><a href="#什么是IEEE754标准？" class="headerlink" title="什么是IEEE754标准？"></a>什么是IEEE754标准？</h5><p><strong>以双精度为例，相比于传统浮点位，IEEE754标准使传统阶码标准之上，偏置常数从原来的10000000000(2^(n-1))变为00000000000(2^(n-1)-1),即隐藏移码，从原来的1024变成1023，这种做法有两个好处<br>1、尾数可表示的位数多一位，因而使得浮点数的精度更高。<br>2、阶码的可表示范围更大，因而使浮点数表示范围更大</strong></p><h5 id="IEEE754解释："><a href="#IEEE754解释：" class="headerlink" title="IEEE754解释："></a>IEEE754解释：</h5><h5 id="question"><a href="#question" class="headerlink" title="question:"></a>question:</h5><p>请判断下列关系表达式在32位机子上运行上是否永真，去除无穷大和NAN的任何值,i、f、d分别表示位,int,float,double<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、 i == (int)(float) i   //不相等，因为int为32位，float为23位精度</span><br><span class="line">2、 f == (float)(int)f    //不相等，小数位精度缺失</span><br><span class="line">3、 i == (int)(double)i   //相等</span><br><span class="line">4、 f == (float)(double)i //相等</span><br></pre></td></tr></table></figure><p></p><h3 id="整数的加减"><a href="#整数的加减" class="headerlink" title="整数的加减"></a>整数的加减</h3><p><img src="/img/loading.gif" data-original="/计算机系统基础/basic-computer-sience-chapter2/choiceTwoWay.jpg" alt="choiceTwoWay"><br>零标志位为zf，溢出标志位位of；<br>符号标志sf，进/借位标志cf<br>zf=1时，表示结果为0；<br>of=1时，表示带符号整数的加减法运算发生溢出；<br>cf=Sub异或C</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>这章也为我解释了为什么int型到达一定的位数之后会由正数变成负数。溢出让我更清晰的明白了其中的原理。还有浮点数，让我明白了大数加1之后并没有什么变化的最基础原理。IEEE754标准也让我更加清晰了浮点数的存储方式，以及其工作原理。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/img/logo-gray.jpg" alt="gdccwxx"><p class="site-author-name" itemprop="name">gdccwxx</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/gdccwxx" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:765553928@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">gdccwxx</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=r[a],t=e,n=function(){r=r.filter(function(t){return e!==t})},i=new Image,o=t.getAttribute("data-original");i.onload=function(){t.src=o,n()},t.src!==o&&(i.src=o)}()}o(),n.addEventListener("scroll",function(){var t=o,e=n;clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>