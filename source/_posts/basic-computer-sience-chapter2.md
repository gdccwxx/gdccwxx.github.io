---
title: 计算机系统基础－－第二章(数据的机器级表示与处理)
date: 2017-05-22 21:20:53
tags: 计算机系统基础
---
### 数制转换
即将不同的数值转换，例如：二、八、十六进制的相互转换
```
八进制转二进制：　0 Q = 000 B    1 Q = 001 B     7 Q = 111 B
十六进制转二进制：　0 H = 0000 B      5 H =0101 B     F H = 1111 B
tips: 可知八进制转二进制与十六进制转二进制分别对应着３位以及４位的二进制
```
其他进制转二进制，例如：十进制与二进制的相互转换
```
0 D = 0000 H    10 D = 1010 B   100 D = 1100100 B
而无明显进制位数比较
```
多进制转化为10进制，例如16进制转化为10进制
```
1 H = 1*16^0 D      F H = 15*16^0 D     8FF H = 8*16^2+15*16^1+15*16^0 D
可较为明确的转化
```
结论：多进制转换为二进制无明显比较。可由多进制转化为10进制后，再转化为其他进制。可参[简易的进制转换器](https://github.com/gdccwxx/just-play/tree/master/hexConversion)
### 定点编码表示
##### 原码表示法
也称“符号－数值”
规则：
１、当Xt 为正数时，　Xn-1 = 0 Xi=X’i(0<=i<=n-2);
２、当Xt 为负数时，　Xn-1 = 1 Xi=X’i(0<=i<=n-2);
即：-10 用八位原码表示为10001010B，10 用八位原码表示为00001010B
优点：真之对应关系直接方便简单，而且用原码实现乘除运算也较为简单。
缺点：０表示不唯一(0000,1000都表示0)加减运算需判断是否同好或异号。
运用：现代计算机中不用原码表示正数，只用定点源码小数表示浮点数的尾数部分。
##### 补码表示法
也称“２－补码”
规则：
１、当Xt 为正数时，　[Xt]补　= Xt = M+Xt(mod M);
２、当Xt 为负数时，　[Xt]补　= M - |Xt| = M+Xt(mod M);
即：[1101100]补　= 2^8 + 1101100 = 100000000 + 1101100(mod 2^8) = 01101100
[-1101100]补　= 2^8 - 1101100 = 100000000 - 1101100 = 10000000 + (1111111 - 1101100) + 1 = 10000000 + 0010011 + 1(mod 2^8) = 10010100
优点：１、减少了-0与+0的切换
2、占用少一个编码表示，补码比原码能多表示一个最小负数，可以用-2^(n-1)来表示最小负数。
3、两数的补码之和（差）=两数和（差）的补码。
运用：在计算机中，补码用来表示带符号正数。
##### 反码表示法
规则：
正数和原码相同，负数的补码采用“各位取反，末尾加1”
即： [01100]反 = [10100]反
缺点：1、0的表示不唯一。
2、表数范围比补码少一个最小负数。
3、运算时必须考虑循环进位。
运用：反码在计算机中很少被使用，有事做数码变换的中间表示形式（我们可以快速从反码知道原码和补码）。
##### 移码表示法
规则：
[E]移 = 偏置常数 + E （偏置常数通常取2^(n-1)或2^(n-1)-1）
运用：通常表示浮点数的阶（即指数）
##### 浮点数的表示(IEEE754浮点数)
IEEE754浮点数的表示：
![ieee754image](ieee754image.png)
![chart_of_iee754](IEEE754_chart.jpg)
sign: 符号位，0表示正数1表示负数
exponent： 阶码，由偏置常数+偏移量组成
function： 位数
##### 为什么要有IEEE754标准？
**答：在此标准出来之前，不同电脑中的浮点数表示不唯一，一个程序由此电脑移到彼电脑可能需要重新编码。为了让程序员更加专心于程序的本身，而非多个不同电脑的差异做无用功，因此出现IEEE754标准**
##### 什么是IEEE754标准？
**以双精度为例，相比于传统浮点位，IEEE754标准使传统阶码标准之上，偏置常数从原来的10000000000(2^(n-1))变为00000000000(2^(n-1)-1),即隐藏移码，从原来的1024变成1023，这种做法有两个好处
1、尾数可表示的位数多一位，因而使得浮点数的精度更高。
2、阶码的可表示范围更大，因而使浮点数表示范围更大**
##### IEEE754解释：
##### question:
请判断下列关系表达式在32位机子上运行上是否永真，去除无穷大和NAN的任何值,i、f、d分别表示位,int,float,double
```
1、 i == (int)(float) i   //不相等，因为int为32位，float为23位精度
2、 f == (float)(int)f    //不相等，小数位精度缺失
3、 i == (int)(double)i   //相等
4、 f == (float)(double)i //相等
```
### 整数的加减

![choiceTwoWay](choiceTwoWay.jpg)
零标志位为zf，溢出标志位位of；
符号标志sf，进/借位标志cf
zf=1时，表示结果为0；
of=1时，表示带符号整数的加减法运算发生溢出；
cf=Sub异或C


#### 小结：
这章也为我解释了为什么int型到达一定的位数之后会由正数变成负数。溢出让我更清晰的明白了其中的原理。还有浮点数，让我明白了大数加1之后并没有什么变化的最基础原理。IEEE754标准也让我更加清晰了浮点数的存储方式，以及其工作原理。

