<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="vz1PrlmOl-C4FBrH_at-JOEneuzGOz7AfXa3QVThvy8"><meta name="baidu-site-verification" content="code-4IMpMXQpb6"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon.ico?v=5.1.4"><meta name="keywords" content="你不知道的javascript————类型和语法"><meta name="description" content="类型七个内置类型空值 (null)未定义 (undefined)布尔值 (boolean)数字 (number)字符串 (string)对象 (object)符号 (symbol)检测各个类型123456789typeof undefined		=== &amp;quot;undefined&amp;quot; 	// truetypeof true 				=== &amp;quot;boolean&amp;quot;			/"><meta name="keywords" content="你不知道的javascript————类型和语法"><meta property="og:type" content="article"><meta property="og:title" content="你不知道的javascript————类型和语法"><meta property="og:url" content="https://blog.gdccwxx.com/JavaScript/you-dont-konwn-javascript-type/index.html"><meta property="og:site_name" content="gdccwxx"><meta property="og:description" content="类型七个内置类型空值 (null)未定义 (undefined)布尔值 (boolean)数字 (number)字符串 (string)对象 (object)符号 (symbol)检测各个类型123456789typeof undefined		=== &amp;quot;undefined&amp;quot; 	// truetypeof true 				=== &amp;quot;boolean&amp;quot;			/"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2021-09-11T05:41:58.306Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="你不知道的javascript————类型和语法"><meta name="twitter:description" content="类型七个内置类型空值 (null)未定义 (undefined)布尔值 (boolean)数字 (number)字符串 (string)对象 (object)符号 (symbol)检测各个类型123456789typeof undefined		=== &amp;quot;undefined&amp;quot; 	// truetypeof true 				=== &amp;quot;boolean&amp;quot;			/"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_header:"slideDownIn",post_body:"slideDownIn"}},duoshuo:{userId:"undefined",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://blog.gdccwxx.com/JavaScript/you-dont-konwn-javascript-type/"><title>你不知道的javascript————类型和语法 | gdccwxx</title><script>!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-118405225-1","auto"),ga("send","pageview")</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">gdccwxx</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">:)</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.gdccwxx.com/JavaScript/you-dont-konwn-javascript-type/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="gdccwxx"><meta itemprop="description" content><meta itemprop="image" content="/img/logo-gray.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="gdccwxx"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">你不知道的javascript————类型和语法</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T21:17:15+08:00">2017-12-17</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="七个内置类型"><a href="#七个内置类型" class="headerlink" title="七个内置类型"></a>七个内置类型</h4><ul><li>空值 (null)</li><li>未定义 (undefined)</li><li>布尔值 (boolean)</li><li>数字 (number)</li><li>字符串 (string)</li><li>对象 (object)</li><li>符号 (symbol)</li></ul><h4 id="检测各个类型"><a href="#检测各个类型" class="headerlink" title="检测各个类型"></a>检测各个类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined		=== &quot;undefined&quot; 	// true</span><br><span class="line">typeof true 				=== &quot;boolean&quot;			// true</span><br><span class="line">typeof 42						=== &quot;number&quot;			// true</span><br><span class="line">typeof &quot;42&quot; 				=== &quot;string&quot;			// true</span><br><span class="line">typeof &#123;&quot;life&quot;: 42&#125;	=== &quot;object&quot;			// true</span><br><span class="line">typeof Symbol				=== &quot;symbol&quot;			// true</span><br><span class="line">typeof null 				=== &quot;object&quot;			// true</span><br><span class="line">typeof function()&#123;&#125;	=== &quot;function&quot; 		// true</span><br><span class="line">typeof [0,1]				=== &quot;object&quot;			// true</span><br></pre></td></tr></table></figure><p>本身null对象里面代表空值，所以其为object也是合理。但应该typeof null 返回是 null才符合常理。由于这个bug在许多代码中已经这样做了，所以重新修回会导致更严重的bug。因此被修回的可能性很小。<br>因此，对null应该采用复合查询语句<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = null;</span><br><span class="line">(!a &amp;&amp; typeof a === &quot;object&quot;)	// true</span><br></pre></td></tr></table></figure><p></p><p>而对于typeof function(){} === “function” 而言，因为本身function是object的一个子类型，具体的说，函数是一个可调用对象。<br>且typeof [0,1] === “object”,因为数组也是object的一个子类型</p><p><em>ps：由于所有的typeof都会返回一个string，所以 typeof typeof 42会是”string”，因为typeof 42首先会变成一个“number”，是一个string类型，所以typeof “number”是一个string</em></p><h4 id="undefined-amp-amp-undeclared-amp-amp-typeof-undeclared"><a href="#undefined-amp-amp-undeclared-amp-amp-typeof-undeclared" class="headerlink" title="undefined &amp;&amp; undeclared &amp;&amp; typeof undeclared"></a>undefined &amp;&amp; undeclared &amp;&amp; typeof undeclared</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">typeof a;			// &quot;undefined&quot;</span><br><span class="line">var b = 42;</span><br><span class="line">var c;</span><br><span class="line">b=c;</span><br><span class="line">typeof c			// &quot;undefined&quot;</span><br><span class="line">typeof b			// &quot;undefined&quot;</span><br><span class="line">a							// &quot;undefined&quot;</span><br><span class="line">d							// &quot;VM422:1 Uncaught ReferenceError: d is not defined at &lt;anonymous&gt;:1:1&quot;</span><br></pre></td></tr></table></figure><p>从上述可以看出，undefined 和 undeclared 是两码事。undefined意思是定义但未赋值，或者赋值为undefined，而undeclared是未定义。因此两者不能画等号</p><h4 id="typeof-undeclared"><a href="#typeof-undeclared" class="headerlink" title="typeof undeclared"></a>typeof undeclared</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof a			// &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p>出现这种原因因为typeof有一个特殊的安全防范机制，因为多个脚本文件会在共享的全局变量命名空间中加载变量。如果typeof一个未命名的报错，会导致整段程序停止运行。对于typeof来检查undeclared变量，有时是一个不错的办法。</p><h4 id="值"><a href="#值" class="headerlink" title="值"></a>值</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>js的数组可以容纳任何的值，甚至可以是另一个数组，因此多维数组就是这种方式来实现的。<br>由于数组本身就是一个特殊的对象，所以数组也可以包含字符串键值和属性，但是这并不计算在数组长度内。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">a[0] = 1;</span><br><span class="line">a[&quot;foobar&quot;] = 1;</span><br><span class="line">a.length 			// 1</span><br><span class="line">a[&quot;foobar&quot;];	// 1</span><br><span class="line">a.foobar			// 1</span><br><span class="line">a[&quot;13&quot;] = 42;</span><br><span class="line">a.length		// 14</span><br></pre></td></tr></table></figure><p></p><p>为什么会这样呢？由于本身数组就是一个对象的子集合，因此在[]中，使用十进制字符串数字会直接强制类型转化成数字。a[“13”]就变成了a[13],因此在数组内会直接将其长度变化成14。同理，在属性给foobar加到a数组中，因为数组的界定是有数字来确定下标位置，而length是最后一个下标数字+1，因而加入的非数字就不在长度里面了。</p><h5 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h5><p>对于es5而言，可以用slice,concat来实现类数组转数组，对于es6而言，可以用Array.from()来实现从类数组转换成数组。</p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>字符串的一些方法indexOf(),concat(),toUpperCase(),reverse()等等。<br>字符串的一些方法：<br>|方法|描述|<br>|—|—|<br>|charAt() | 返回指定索引位置的字符|<br>|charCodeAt() | 返回指定索引位置字符的 Unicode 值|<br>|concat() | 连接两个或多个字符串，返回连接后的字符串|<br>|fromCharCode() | 将 Unicode 转换为字符串|<br>|indexOf() | 返回字符串中检索指定字符第一次出现的位置|<br>|lastIndexOf() | 返回字符串中检索指定字符最后一次出现的位置|<br>|localeCompare() | 用本地特定的顺序来比较两个字符串|<br>|match() | 找到一个或多个正则表达式的匹配|<br>|replace() | 替换与正则表达式匹配的子串|<br>|search() | 检索与正则表达式相匹配的值|<br>|slice() | 提取字符串的片断，并在新的字符串中返回被提取的部分|<br>|split() | 把字符串分割为子字符串数组|<br>|substr() | 从起始索引号提取字符串中指定数目的字符|<br>|substring() | 提取字符串中两个指定的索引号之间的字符|<br>|toLocaleLowerCase() | 根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射|<br>|toLocaleUpperCase() | 根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射|<br>|toLowerCase() | 把字符串转换为小写|<br>|toString() | 返回字符串对象值|<br>|toUpperCase() | 把字符串转换为大写|<br>|trim() | 移除字符串首尾空白|<br>|valueOf() | 返回某个字符串对象的原始值|</p><p>如果需要经常一字符数组的方式来处理字符串的话，倒不如直接用数组。这样就不用在字符串和数组之间来回折腾。可以在有需要的时候使用join(“”)来将字符串数组转换为字符串</p><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>和大部分编程语言一样，js中的数字是基于IEE754标准来实现的。该标准通常也被称为“浮点数”。而js使用的是双精度单位(64位)格式。所以也会有iee754标准的通病，即浮点数之间相加会有奇妙的现象。<br>数字的一些方法：<br>toExponential()<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var a = 5E10			// 可以通过这种方式赋值</span><br><span class="line">a									// 50000000000</span><br><span class="line">a.toExponential()	// &quot;5e+10&quot;</span><br><span class="line">var b = a * a;</span><br><span class="line">b 								// 2.5e+21</span><br><span class="line">```	</span><br><span class="line">toFixed()					// 精度</span><br><span class="line">```bash</span><br><span class="line">var a = 42.59</span><br><span class="line">a.toFixed(1)			// &quot;42.6&quot;</span><br><span class="line">// 无效</span><br><span class="line">42.toFixed(3)			// Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line">// 有效</span><br><span class="line">42..toFixed(3)		// &quot;42.000&quot;</span><br><span class="line">(42).toFixed(3)		// &quot;42.000&quot;</span><br><span class="line">0.42.toFixed(3)		// &quot;0.420&quot;</span><br><span class="line">42 .toFixed(3)		// &quot;42.000&quot;</span><br></pre></td></tr></table></figure><p></p><p>因为.被视为常量42.的一部分。所以没有.属性访问运算符来调用toFixed()<br>toPrecision() // 执行有效位数的显示位数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 42.59</span><br><span class="line">a.toPrecision(1)		// &quot;4e+1&quot;</span><br><span class="line">a.toPrecision(2)		// &quot;43&quot;</span><br><span class="line">a.toPrecision(3)		// &quot;42.6&quot;</span><br><span class="line">``` </span><br><span class="line">es6支持新格式</span><br><span class="line">```bash</span><br><span class="line">0B		0b					// 二进制</span><br><span class="line">0O		0o					// 八进制</span><br><span class="line">0X		0x					// 十六进制</span><br></pre></td></tr></table></figure><p></p><p>EPSILON // 最小精度<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(((0.1 + 0.2) - 0.3)&lt;Number.EPSILON)&#123;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>MAX_VALUE<br>MAX_SAFE_INTEGER<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_VALUE						// 1.7976931348623157e+308</span><br><span class="line">Number.MAX_SAFE_INTEGER			// 9007199254740991</span><br></pre></td></tr></table></figure><p></p><p>isInteger<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(1)					// true</span><br><span class="line">Number.isInteger(1.1)				// false</span><br><span class="line">Number.isInteger(1.0)				// true</span><br></pre></td></tr></table></figure><p></p><h4 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h4><h5 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var undefined = 2</span><br><span class="line">undefined 	// 2</span><br></pre></td></tr></table></figure><p><em>ps：永远不要重新定义undefined</em></p><h4 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h4><p>在不需要返回值的时候，可以void掉<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(ready)&#123;</span><br><span class="line">	return void setTimeout(..)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样做可以将setTimeout返回的id给void掉</p><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>NaN是一个数值型。意思指的是不是一个数值，并且NaN != NaN。可以使用isNaN来判断是否是NaN<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(NaN)				// true</span><br><span class="line">Number.isNaN(1)					// false</span><br></pre></td></tr></table></figure><p></p><h4 id="0值"><a href="#0值" class="headerlink" title="0值"></a>0值</h4><p>加法和减法运算永远不会有-0<br>使用toString和JSON.stringify()会将-0变成0<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0/-1			// -0</span><br><span class="line">0/1				// 0</span><br><span class="line">var a = -0</span><br><span class="line">a 				// -0</span><br><span class="line">a.toString()		// 0</span><br><span class="line">JSON.stringify(a)	// 0</span><br></pre></td></tr></table></figure><p></p><h4 id="特殊等式"><a href="#特殊等式" class="headerlink" title="特殊等式"></a>特殊等式</h4><p>Object.is<br>Object.is 可以判断是+0还是-0,而且可以判断是否为NaN<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.is(+0, -0)	// false</span><br><span class="line">Object.is(NaN, NaN)		// true</span><br></pre></td></tr></table></figure><p></p><h4 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h4><p>null，undefined，字符串，数字，布尔，symbol都是简单值<br>对象，函数都是复杂值<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function foo(x) &#123;</span><br><span class="line">	x.push(4);	</span><br><span class="line">	x;							// [1,2,3,4]</span><br><span class="line">	x = [4,5,6];</span><br><span class="line">	x.push(7);</span><br><span class="line">	x;							// [4,5,6,7]</span><br><span class="line">&#125;</span><br><span class="line">var a = [1,2,3];</span><br><span class="line">foo(a);</span><br><span class="line">a;				// [1,2,3,4]</span><br><span class="line">由于一开始是引用赋值，然后x是a对应数组的一个引用，x在push一个4之后，重新引用一个新的数组，4.5.6,而a引用的数组变化成了[1,2,3,4];</span><br><span class="line">function foo(x)&#123;</span><br><span class="line">	x.push(4);</span><br><span class="line">	x;				// [1,2,3,4]</span><br><span class="line">	x.length = 0;	</span><br><span class="line">	x.push(4,5,6,7)</span><br><span class="line">	x;				// [4,5,6,7]</span><br><span class="line">&#125;</span><br><span class="line">var a = [1,2,3]</span><br><span class="line">foo(a)</span><br><span class="line">a;		// [4,5,6,7]</span><br><span class="line">和上面一开始一样，只是后面在x.length=0后，再push进去了4,5,6,7。所以x的引用没变，还是和a引用的一样。所以a和x一同变化</span><br></pre></td></tr></table></figure><p></p><p><em>ps：我们无法自行决定使用值赋值还是引用赋值，一切由值的类型决定</em><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function foo(warpper)&#123;</span><br><span class="line">	warpper.a = 42</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 1</span><br><span class="line">&#125;</span><br><span class="line">foo(obj)</span><br><span class="line">obj.a			//42</span><br><span class="line">function foo (x) &#123;</span><br><span class="line">	x = x+1;</span><br><span class="line">	x;				// 3</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">var b = new Number(a);</span><br><span class="line">foo(b)</span><br><span class="line">console.log(b)		// 2</span><br><span class="line">前者是引用赋值，后者是值赋值</span><br></pre></td></tr></table></figure><p></p><h4 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h4><ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Function</li><li>RegExp</li><li>Date</li><li>Error</li><li>Symbol</li></ul><h4 id="内部属性-Class"><a href="#内部属性-Class" class="headerlink" title="内部属性[[Class]]"></a>内部属性[[Class]]</h4><p>所有typeof返回值为“Object”的对象(如数组)都包含一个内部属性[[Class]]，这个属性通常无法直接访问，一般通过Object.prototype.toString查看<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call([123])			// &quot;[object Array]&quot;</span><br><span class="line">Object.prototype.toString.call(null)			// &quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(true)			// &quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined)	// &quot;[object Undefined]&quot;</span><br></pre></td></tr></table></figure><p></p><p>虽然Null和undefined这样的原声构造函数不存在，但是内部Class属性值仍然是Null和Undefined。基本类型值被各自的封装对象自动包装，所以他们的内部[[Class]]属性值为Boolean。</p><h4 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;abc&quot;;</span><br><span class="line">console.log(a);		// &quot;abc&quot;</span><br><span class="line">a.length 					// &quot;3&quot;</span><br><span class="line">var b = new String(&quot;abc&quot;)</span><br><span class="line">console.log(b)		// String &#123;[[PrimitiveValue]]: &quot;abc&quot;&#125; 0:&quot;a&quot; 1:&quot;b&quot; 2:&quot;c&quot; length:3 __proto__:String [[PrimitiveValue]]:&quot;abc&quot;</span><br></pre></td></tr></table></figure><p>只是创建字面量基本值的时候，并没有其他的方法。当在使用其对象方法时，需要通过封装对象才能访问，此时js会自动为基本类型值包装(box或者wrap)一个封装对象。<br>但是为经常用到的.length方法直接new一个对象也不是一个好办法，因为浏览器对.length这样的常见情况做了优化，直接使用封装对象来“提前优化”反而会降低执行效率。</p><h4 id="封装对象的释疑"><a href="#封装对象的释疑" class="headerlink" title="封装对象的释疑"></a>封装对象的释疑</h4><p>例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = new Boolean(false);</span><br><span class="line">if (!a)&#123;</span><br><span class="line">	console.log(...)			// 执行不到这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为建立一个a之后，这个对象得到的是真值，得到的结果和使用false相反</p><p>自行封装可以使用Object<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;abc&quot;</span><br><span class="line">var b = new String (a);</span><br><span class="line">var c = Object(a);</span><br><span class="line">typeof a 				// &quot;stirng&quot;</span><br><span class="line">typeof b				// &quot;object&quot;</span><br><span class="line">typeof c				// &quot;object&quot;</span><br><span class="line">b instanceof String 	// true</span><br><span class="line">c instanceof String 	// true</span><br><span class="line">Object.prototype.toString.call(b);		// &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(c);		// &quot;[object String]&quot;</span><br></pre></td></tr></table></figure><p></p><p>一般不直接使用封装对象，但是他们偶尔也会派上用场</p><h4 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h4><p>如果想得到封装对象里面的值，可以使用valueOf函数，隐式拆封也是调用了valueOf函数：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = new String(&quot;abc&quot;)</span><br><span class="line">var b = new Number(11)</span><br><span class="line">var c = new Boolean(true)</span><br><span class="line">a.valueOf()	// &quot;abc&quot;</span><br><span class="line">b.valueOf()	// 11</span><br><span class="line">c.valueOf()	// true</span><br><span class="line">var d = a + &quot;&quot;;</span><br><span class="line">console.log(d)				// &quot;abc&quot;</span><br><span class="line">typeof a 			// &quot;object&quot;</span><br><span class="line">typeof d 			// &quot;string&quot;</span><br></pre></td></tr></table></figure><p></p><h4 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h4><p>四种方式创建应该尽量避免构造函数，除非十分必要</p><ul><li>array 数组</li><li>object 对象</li><li>function 函数</li><li>RegExp 正则表达式<h3 id="ARRAY"><a href="#ARRAY" class="headerlink" title="ARRAY(..)"></a>ARRAY(..)</h3>调用Array构造函数时，可以不需要加上new，效果一致。）且Array构造函数纸袋一个数字作为参数的时候，这个参数会当作数组的预设长度，而不是充当其中的一个元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 效果一致</span><br><span class="line">var a = new Array(1,2,3);</span><br><span class="line">a			// [1,2,3]</span><br><span class="line">var b = Array(1,2,3)</span><br><span class="line">b 		// [1,2,3]</span><br><span class="line">var c = [1,2,3]</span><br><span class="line">c 		// [1,2,3]</span><br><span class="line">// 不同方式创建出来空数组效果不一致</span><br><span class="line">var d = new Array(3);</span><br><span class="line">console.log(d)			// chrome上： (3) [empty × 3]</span><br><span class="line">d.length						// 3</span><br><span class="line">var e = [undefined,undefined,undefined];</span><br><span class="line">console.log(e)			// (3) [undefined, undefined, undefined]</span><br><span class="line">var f = []					</span><br><span class="line">f.length = 3;</span><br><span class="line">console.log(f);			// chrome上： (3) [empty × 3]</span><br><span class="line">// 直接以，创建。虽然长度是3令人费解，但是可以更好的复制粘贴</span><br><span class="line">var g = [,,,]</span><br><span class="line">console.log(g)			// chrome上： (3) [empty × 3]</span><br></pre></td></tr></table></figure></li></ul><p>由于创建方式不同，导致在chrome下不一致的显示，但是更难过的是，他们有时相同，有时呵呵<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = new Array(3)</span><br><span class="line">var b = [undefined,undefined,undefined]</span><br><span class="line">a.join(&quot;-&quot;)			// &quot;--&quot;</span><br><span class="line">b.join(&quot;-&quot;)			// &quot;--&quot;</span><br><span class="line">a.map(function(v,i)&#123;return i&#125;)		// (3) [empty × 3]</span><br><span class="line">a.map(function(v,i)&#123;return i&#125;)		// [0, 1, 2]</span><br></pre></td></tr></table></figure><p></p><p>a.map之所以执行失败，是因为a中是没有元素的，而b里面有undefied。<br><strong>而join首先假定数组不为空，然后通过length属性值来便利其中的元素，而map并不做这种假定</strong><br>可以通过这种方式来创建包含undefined单元的数组<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = Array.apply(null, &#123;length:3&#125;);</span><br><span class="line">console.log(a)			// (3) [undefined, undefined, undefined]</span><br></pre></td></tr></table></figure><p></p><p><em>PS:永远不要创建和使用空单元数组</em></p><h4 id="OBJECT、FUNCTION、REGEXP"><a href="#OBJECT、FUNCTION、REGEXP" class="headerlink" title="OBJECT、FUNCTION、REGEXP"></a>OBJECT、FUNCTION、REGEXP</h4><p><strong>除非玩不得已，尽量不要使用他们</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var c = new Object();</span><br><span class="line">c.foo = &quot;bar&quot;;</span><br><span class="line">c				// &#123;foo:&quot;bar&quot;&#125;</span><br><span class="line">var d = &#123;foo:&quot;bar&quot;&#125;</span><br><span class="line">d				// &#123;foo:&quot;bar&quot;&#125;</span><br><span class="line">var e = new Function(&quot;a&quot;,&quot;return a * 2&quot;);</span><br><span class="line">var f = function(a)&#123;return a*2&#125;;</span><br><span class="line">function g(a)&#123;return a*2&#125;</span><br><span class="line">var h = new RegExp(&quot;^a*b+&quot;,&quot;g&quot;);</span><br><span class="line">var i = /^a*b+/g</span><br></pre></td></tr></table></figure><p></p><p>javascript对常量形式的代码会对他们进行预编译和缓存！</p><h4 id="DATE、ERROR"><a href="#DATE、ERROR" class="headerlink" title="DATE、ERROR"></a>DATE、ERROR</h4><p>相较于其他原生构造函数，Date、Error的用处比其他的更多，因为没有其他对用的常量形式来作为他们的替代<br>引入生成当前时间戳，使用<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date.now()</span><br><span class="line">// 使用new来生成时间</span><br><span class="line">new Date()</span><br><span class="line">// Thu Jan 04 2018 06:47:59 GMT+0800 (CST)</span><br></pre></td></tr></table></figure><p></p><p>错误对象通常与throw一起使用<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(x)&#123;</span><br><span class="line">	if(!x)&#123;</span><br><span class="line">		throw new Error(&quot;///&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	// -</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="SYMBOL"><a href="#SYMBOL" class="headerlink" title="SYMBOL"></a>SYMBOL</h4><p>Symbol可作为私有属性是一种简单标量基本类型</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><h4 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h4><p>如果对象有自己的toString()方法，字符串化就会调用该方法并使用其返回值。<br>数组的默认toString方法经过了重新定义<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3]</span><br><span class="line">a.toString()		// &quot;1,2,3&quot;</span><br></pre></td></tr></table></figure><p></p><h4 id="JSON-字符串化"><a href="#JSON-字符串化" class="headerlink" title="JSON 字符串化"></a>JSON 字符串化</h4><p>JSON.stringify(42) // “42”<br>JSON.stringify(“42”) // “”42””<br>JSON.stringify(null) // “null”<br>JSON.stringify(true) // “true”</p><p><em>JSON.stringify()在对象中遇到undefined、function和symbol时会自动将其忽略，在数组中则会返回null</em><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(undefined)			// undefined</span><br><span class="line">JSON.stringify(function()&#123;&#125;)	// undefined</span><br><span class="line">JSON.stringify([1,undefined, function()&#123;&#125;,4])	// &quot;[1,null,null,4]&quot;</span><br><span class="line">JSON.stringify(&#123;a:2, b: function()&#123;&#125;&#125;)				// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span><br></pre></td></tr></table></figure><p></p><p>循环引用会出错<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line">var a = &#123;</span><br><span class="line">	b:42,</span><br><span class="line">	c:o,</span><br><span class="line">	d:function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">o.e = a</span><br><span class="line">JSON.stringify(a)</span><br><span class="line">a.toJSON=function()&#123;</span><br><span class="line">	return &#123;b:this.b&#125;</span><br><span class="line">&#125;</span><br><span class="line">JSON.stringify(a)</span><br><span class="line"># Uncaught TypeError: Converting circular structure to JSON</span><br><span class="line">#     at JSON.stringify (&lt;anonymous&gt;)</span><br><span class="line">#     at &lt;anonymous&gt;:8:6</span><br></pre></td></tr></table></figure><p></p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/img/wechat.png" alt="gdccwxx 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/img/alipay.jpeg" alt="gdccwxx 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JavaScript/" rel="tag"># JavaScript</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/随笔/2017-ele-Interecommunions/" rel="next" title="2017饿了么前端交流会"><i class="fa fa-chevron-left"></i> 2017饿了么前端交流会</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/随笔/2017-summery/" rel="prev" title="2017总结">2017总结 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/img/logo-gray.jpg" alt="gdccwxx"><p class="site-author-name" itemprop="name">gdccwxx</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">16</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/gdccwxx" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:765553928@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型"><span class="nav-number">1.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#七个内置类型"><span class="nav-number">1.1.</span> <span class="nav-text">七个内置类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检测各个类型"><span class="nav-number">1.2.</span> <span class="nav-text">检测各个类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined-amp-amp-undeclared-amp-amp-typeof-undeclared"><span class="nav-number">1.3.</span> <span class="nav-text">undefined &amp;&amp; undeclared &amp;&amp; typeof undeclared</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typeof-undeclared"><span class="nav-number">1.4.</span> <span class="nav-text">typeof undeclared</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#值"><span class="nav-number">1.5.</span> <span class="nav-text">值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数组"><span class="nav-number">1.5.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类数组"><span class="nav-number">1.5.2.</span> <span class="nav-text">类数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串"><span class="nav-number">1.5.3.</span> <span class="nav-text">字符串</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数字"><span class="nav-number">1.6.</span> <span class="nav-text">数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特殊数值"><span class="nav-number">1.7.</span> <span class="nav-text">特殊数值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined"><span class="nav-number">1.7.1.</span> <span class="nav-text">undefined</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-运算符"><span class="nav-number">1.8.</span> <span class="nav-text">void 运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NaN"><span class="nav-number">1.9.</span> <span class="nav-text">NaN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#0值"><span class="nav-number">1.10.</span> <span class="nav-text">0值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特殊等式"><span class="nav-number">1.11.</span> <span class="nav-text">特殊等式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#值和引用"><span class="nav-number">1.12.</span> <span class="nav-text">值和引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原生函数"><span class="nav-number">1.13.</span> <span class="nav-text">原生函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部属性-Class"><span class="nav-number">1.14.</span> <span class="nav-text">内部属性[[Class]]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装对象包装"><span class="nav-number">1.15.</span> <span class="nav-text">封装对象包装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装对象的释疑"><span class="nav-number">1.16.</span> <span class="nav-text">封装对象的释疑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拆封"><span class="nav-number">1.17.</span> <span class="nav-text">拆封</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原生函数作为构造函数"><span class="nav-number">1.18.</span> <span class="nav-text">原生函数作为构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARRAY"><span class="nav-number">2.</span> <span class="nav-text">ARRAY(..)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OBJECT、FUNCTION、REGEXP"><span class="nav-number">2.1.</span> <span class="nav-text">OBJECT、FUNCTION、REGEXP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DATE、ERROR"><span class="nav-number">2.2.</span> <span class="nav-text">DATE、ERROR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SYMBOL"><span class="nav-number">2.3.</span> <span class="nav-text">SYMBOL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强制类型转换"><span class="nav-number">3.</span> <span class="nav-text">强制类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象值操作"><span class="nav-number">3.1.</span> <span class="nav-text">抽象值操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON-字符串化"><span class="nav-number">3.2.</span> <span class="nav-text">JSON 字符串化</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">gdccwxx</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>